{"/home/travis/build/npmtest/node-npmtest-botkit/test.js":"/* istanbul instrument in package npmtest_botkit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-botkit/lib.npmtest_botkit.js":"/* istanbul instrument in package npmtest_botkit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_botkit = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_botkit = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-botkit/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-botkit && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_botkit */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_botkit\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_botkit.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_botkit.rollup.js'] =\n            local.assetsDict['/assets.npmtest_botkit.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_botkit.__dirname +\n                    '/lib.npmtest_botkit.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/Botkit.js":"var CoreBot = require(__dirname + '/CoreBot.js');\nvar Slackbot = require(__dirname + '/SlackBot.js');\nvar Facebookbot = require(__dirname + '/Facebook.js');\nvar TwilioIPMbot = require(__dirname + '/TwilioIPMBot.js');\nvar BotFrameworkBot = require(__dirname + '/BotFramework.js');\nvar SparkBot = require(__dirname + '/CiscoSparkbot.js');\nvar ConsoleBot = require(__dirname + '/ConsoleBot.js');\n\nmodule.exports = {\n    core: CoreBot,\n    slackbot: Slackbot,\n    sparkbot: SparkBot,\n    facebookbot: Facebookbot,\n    twilioipmbot: TwilioIPMbot,\n    botframeworkbot: BotFrameworkBot,\n    consolebot: ConsoleBot,\n};\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/CoreBot.js":"/**\n * This is a module that makes a bot\n * It expects to receive messages via the botkit.receiveMessage function\n * These messages are expected to match Slack's message format.\n **/\nvar mustache = require('mustache');\nvar simple_storage = require(__dirname + '/storage/simple_storage.js');\nvar ConsoleLogger = require(__dirname + '/console_logger.js');\nvar LogLevels = ConsoleLogger.LogLevels;\nvar ware = require('ware');\nvar clone = require('clone');\nvar fs = require('fs');\nvar studio = require('./Studio.js');\nvar os = require('os');\n\nfunction Botkit(configuration) {\n    var botkit = {\n        events: {}, // this will hold event handlers\n        config: {}, // this will hold the configuration\n        tasks: [],\n        taskCount: 0,\n        convoCount: 0,\n        my_version: null,\n        my_user_agent: null,\n        memory_store: {\n            users: {},\n            channels: {},\n            teams: {},\n        }\n    };\n\n    botkit.utterances = {\n        yes: new RegExp(/^(yes|yea|yup|yep|ya|sure|ok|y|yeah|yah)/i),\n        no: new RegExp(/^(no|nah|nope|n)/i),\n        quit: new RegExp(/^(quit|cancel|end|stop|done|exit|nevermind|never mind)/i)\n    };\n\n    // define some middleware points where custom functions\n    // can plug into key points of botkits process\n    botkit.middleware = {\n        send: ware(),\n        receive: ware(),\n        spawn: ware(),\n        heard: ware(),\n        capture: ware(),\n    };\n\n\n    function Conversation(task, message) {\n\n        this.messages = [];\n        this.sent = [];\n        this.transcript = [];\n\n        this.context = {\n            user: message.user,\n            channel: message.channel,\n            bot: task.bot,\n        };\n\n        this.events = {};\n\n        this.vars = {};\n\n        this.threads = {};\n        this.thread = null;\n\n        this.status = 'new';\n        this.task = task;\n        this.source_message = message;\n        this.handler = null;\n        this.responses = {};\n        this.capture_options = {};\n        this.startTime = new Date();\n        this.lastActive = new Date();\n\n        this.collectResponse = function(key, value) {\n            this.responses[key] = value;\n        };\n\n        this.capture = function(response, cb) {\n\n            var that = this;\n            var capture_key = this.sent[this.sent.length - 1].text;\n            botkit.middleware.capture.run(that.task.bot, response, that, function(err, bot, response, convo) {\n                if (response.text) {\n                    response.text = response.text.trim();\n                } else {\n                    response.text = '';\n                }\n\n                if (that.capture_options.key != undefined) {\n                    capture_key = that.capture_options.key;\n                }\n\n                // capture the question that was asked\n                // if text is an array, get 1st\n                if (typeof(that.sent[that.sent.length - 1].text) == 'string') {\n                    response.question = that.sent[that.sent.length - 1].text;\n                } else if (Array.isArray(that.sent[that.sent.length - 1].text)) {\n                    response.question = that.sent[that.sent.length - 1].text[0];\n                } else {\n                    response.question = '';\n                }\n\n                if (that.capture_options.multiple) {\n                    if (!that.responses[capture_key]) {\n                        that.responses[capture_key] = [];\n                    }\n                    that.responses[capture_key].push(response);\n                } else {\n                    that.responses[capture_key] = response;\n                }\n\n                if (cb) cb(response);\n            });\n\n        };\n\n        this.handle = function(message) {\n\n            that = this;\n            this.lastActive = new Date();\n            this.transcript.push(message);\n            botkit.debug('HANDLING MESSAGE IN CONVO', message);\n            // do other stuff like call custom callbacks\n            if (this.handler) {\n                this.capture(message, function(message) {\n                    // if the handler is a normal function, just execute it!\n                    // NOTE: anyone who passes in their own handler has to call\n                    // convo.next() to continue after completing whatever it is they want to do.\n                    if (typeof(that.handler) == 'function') {\n                        that.handler(message, that);\n                    } else {\n                        // handle might be a mapping of keyword to callback.\n                        // lets see if the message matches any of the keywords\n                        var match, patterns = that.handler;\n                        for (var p = 0; p < patterns.length; p++) {\n                            if (patterns[p].pattern && botkit.hears_test([patterns[p].pattern], message)) {\n                                botkit.middleware.heard.run(that.task.bot, message, function(err, bot, message) {\n                                    patterns[p].callback(message, that);\n                                });\n                                return;\n                            }\n                        }\n\n                        // none of the messages matched! What do we do?\n                        // if a default exists, fire it!\n                        for (var p = 0; p < patterns.length; p++) {\n                            if (patterns[p].default) {\n                                botkit.middleware.heard.run(that.task.bot, message, function(err, bot, message) {\n                                    patterns[p].callback(message, that);\n                                });\n                                return;\n                            }\n                        }\n\n                    }\n                });\n            } else {\n                // do nothing\n            }\n        };\n\n        this.setVar = function(field, value) {\n            if (!this.vars) {\n                this.vars = {};\n            }\n            this.vars[field] = value;\n        };\n\n        this.activate = function() {\n            this.task.trigger('conversationStarted', [this]);\n            this.task.botkit.trigger('conversationStarted', [this.task.bot, this]);\n            this.status = 'active';\n        };\n\n        /**\n         * active includes both ACTIVE and ENDING\n         * in order to allow the timeout end scripts to play out\n         **/\n        this.isActive = function() {\n            return (this.status == 'active' || this.status == 'ending');\n        };\n\n        this.deactivate = function() {\n            this.status = 'inactive';\n        };\n\n        this.say = function(message) {\n            this.addMessage(message);\n        };\n\n        this.sayFirst = function(message) {\n            if (typeof(message) == 'string') {\n                message = {\n                    text: message,\n                    channel: this.source_message.channel,\n                };\n            } else {\n                message.channel = this.source_message.channel;\n            }\n            this.messages.unshift(message);\n        };\n\n\n        this.on = function(event, cb) {\n            botkit.debug('Setting up a handler for', event);\n            var events = event.split(/\\,/g);\n            for (var e in events) {\n                if (!this.events[events[e]]) {\n                    this.events[events[e]] = [];\n                }\n                this.events[events[e]].push(cb);\n            }\n            return this;\n        };\n\n        this.trigger = function(event, data) {\n            if (this.events[event]) {\n                for (var e = 0; e < this.events[event].length; e++) {\n                    var res = this.events[event][e].apply(this, data);\n                    if (res === false) {\n                        return;\n                    }\n                }\n            } else {\n            }\n        };\n\n        // proceed to the next message after waiting for an answer\n        this.next = function() {\n            this.handler = null;\n        };\n\n        this.repeat = function() {\n            if (this.sent.length) {\n                this.messages.push(this.sent[this.sent.length - 1]);\n            } else {\n                // console.log('TRIED TO REPEAT, NOTHING TO SAY');\n            }\n        };\n\n        this.silentRepeat = function() {\n            return;\n        };\n\n        this.addQuestion = function(message, cb, capture_options, thread) {\n            if (typeof(message) == 'string') {\n                message = {\n                    text: message,\n                    channel: this.source_message.channel\n                };\n            } else {\n                message.channel = this.source_message.channel;\n            }\n\n            if (capture_options) {\n                message.capture_options = capture_options;\n            }\n\n            message.handler = cb;\n            this.addMessage(message, thread);\n        };\n\n\n        this.ask = function(message, cb, capture_options) {\n            this.addQuestion(message, cb, capture_options, this.thread || 'default');\n        };\n\n        this.addMessage = function(message, thread) {\n            if (!thread) {\n                thread = this.thread;\n            }\n            if (typeof(message) == 'string') {\n                message = {\n                    text: message,\n                    channel: this.source_message.channel,\n                };\n            } else {\n                message.channel = this.source_message.channel;\n            }\n\n            if (!this.threads[thread]) {\n                this.threads[thread] = [];\n            }\n            this.threads[thread].push(message);\n\n            // this is the current topic, so add it here as well\n            if (this.thread == thread) {\n                this.messages.push(message);\n            }\n        };\n\n        // how long should the bot wait while a user answers?\n        this.setTimeout = function(timeout) {\n            this.task.timeLimit = timeout;\n        };\n\n        // For backwards compatibility, wrap gotoThread in its previous name\n        this.changeTopic = function(topic) {\n            this.gotoThread(topic);\n        };\n\n        this.hasThread = function(thread) {\n            return (this.threads[thread] != undefined);\n        };\n\n\n        this.transitionTo = function(thread, message) {\n\n            // add a new transition thread\n            // add this new message to it\n            // set that message action to execute the actual transition\n            // then change threads to transition thread\n\n            var num = 1;\n            while (this.hasThread('transition_' + num)) {\n                num++;\n            }\n\n            var threadname = 'transition_' + num;\n\n            if (typeof(message) == 'string') {\n                message = {\n                    text: message,\n                    action: thread\n                };\n            } else {\n                message.action = thread;\n            }\n\n            this.addMessage(message, threadname);\n\n            this.gotoThread(threadname);\n\n        };\n\n        this.gotoThread = function(thread) {\n            this.thread = thread;\n\n            if (!this.hasThread(thread)) {\n                if (thread == 'default') {\n                    this.threads[thread] = [];\n                } else {\n                    botkit.debug('WARN: gotoThread() to an invalid thread!', thread);\n                    this.stop('unknown_thread');\n                    return;\n                }\n            }\n\n            this.messages = this.threads[thread].slice();\n\n            this.handler = null;\n        };\n\n        this.combineMessages = function(messages) {\n            if (!messages) {\n                return '';\n            }\n\n            if (Array.isArray(messages) && !messages.length) {\n                return '';\n            }\n\n            if (messages.length > 1) {\n                var txt = [];\n                var last_user = null;\n                var multi_users = false;\n                last_user = messages[0].user;\n                for (var x = 0; x < messages.length; x++) {\n                    if (messages[x].user != last_user) {\n                        multi_users = true;\n                    }\n                }\n                last_user = '';\n                for (var x = 0; x < messages.length; x++) {\n                    if (multi_users && messages[x].user != last_user) {\n                        last_user = messages[x].user;\n                        if (txt.length) {\n                            txt.push('');\n                        }\n                        txt.push('<@' + messages[x].user + '>:');\n                    }\n                    txt.push(messages[x].text);\n                }\n                return txt.join('\\n');\n            } else {\n                if (messages.length) {\n                    return messages[0].text;\n                } else {\n                    return messages.text;\n                }\n            }\n        };\n\n        this.getResponses = function() {\n\n            var res = {};\n            for (var key in this.responses) {\n\n                res[key] = {\n                    question: this.responses[key].length ?\n                     this.responses[key][0].question : this.responses[key].question,\n                    key: key,\n                    answer: this.extractResponse(key),\n                };\n            }\n            return res;\n        };\n\n        this.getResponsesAsArray = function() {\n\n            var res = [];\n            for (var key in this.responses) {\n\n                res.push({\n                    question: this.responses[key].length ?\n                     this.responses[key][0].question : this.responses[key].question,\n                    key: key,\n                    answer: this.extractResponse(key),\n                });\n            }\n            return res;\n        };\n\n\n        this.extractResponses = function() {\n\n            var res = {};\n            for (var key in this.responses) {\n                res[key] = this.extractResponse(key);\n            }\n            return res;\n        };\n\n        this.extractResponse = function(key) {\n            return this.combineMessages(this.responses[key]);\n        };\n\n        this.replaceAttachmentTokens = function(attachments) {\n\n            if (attachments && attachments.length) {\n                for (var a = 0; a < attachments.length; a++) {\n                    for (var key in attachments[a]) {\n                        if (typeof(attachments[a][key]) == 'string') {\n                            attachments[a][key] = this.replaceTokens(attachments[a][key]);\n                        } else {\n                            attachments[a][key] = this.replaceAttachmentTokens(attachments[a][key]);\n                        }\n                    }\n                }\n            } else {\n                for (var a in attachments) {\n                    if (typeof(attachments[a]) == 'string') {\n                        attachments[a] = this.replaceTokens(attachments[a]);\n                    } else {\n                        attachments[a] = this.replaceAttachmentTokens(attachments[a]);\n                    }\n                }\n            }\n\n            return attachments;\n        };\n\n\n        this.replaceTokens = function(text) {\n\n            var vars = {\n                identity: this.task.bot.identity,\n                responses: this.extractResponses(),\n                origin: this.task.source_message,\n                vars: this.vars,\n            };\n\n            var rendered = '';\n\n            try {\n                rendered = mustache.render(text, vars);\n            } catch (err) {\n                botkit.log('Error in message template. Mustache failed with error: ', err);\n                rendered = text;\n            };\n\n            return rendered;\n        };\n\n        this.stop = function(status) {\n            this.handler = null;\n            this.messages = [];\n            this.status = status || 'stopped';\n            botkit.debug('Conversation is over with status ' + this.status);\n            this.task.conversationEnded(this);\n        };\n\n        // was this conversation successful?\n        // return true if it was completed\n        // otherwise, return false\n        // false could indicate a variety of failed states:\n        // manually stopped, timed out, etc\n        this.successful = function() {\n\n            // if the conversation is still going, it can't be successful yet\n            if (this.isActive()) {\n                return false;\n            }\n\n            if (this.status == 'completed') {\n                return true;\n            } else {\n                return false;\n            }\n\n        };\n\n        this.cloneMessage = function(message) {\n            // clone this object so as not to modify source\n            var outbound = clone(message);\n\n            if (typeof(message.text) == 'string') {\n                outbound.text = this.replaceTokens(message.text);\n            } else if (message.text) {\n                outbound.text = this.replaceTokens(\n                    message.text[Math.floor(Math.random() * message.text.length)]\n                );\n            }\n\n            if (outbound.attachments) {\n                outbound.attachments = this.replaceAttachmentTokens(outbound.attachments);\n            }\n\n            if (outbound.attachment) {\n\n                // pick one variation of the message text at random\n                if (outbound.attachment.payload.text && typeof(outbound.attachment.payload.text) != 'string') {\n                    outbound.attachment.payload.text = this.replaceTokens(\n                        outbound.attachment.payload.text[\n                            Math.floor(Math.random() * outbound.attachment.payload.text.length)\n                        ]\n                    );\n                }\n                outbound.attachment = this.replaceAttachmentTokens([outbound.attachment])[0];\n            }\n\n            if (this.messages.length && !message.handler) {\n                outbound.continue_typing = true;\n            }\n\n            if (typeof(message.attachments) == 'function') {\n                outbound.attachments = message.attachments(this);\n            }\n\n            return outbound;\n        };\n\n        this.tick = function() {\n            var now = new Date();\n\n            if (this.isActive()) {\n                if (this.handler) {\n                    // check timeout!\n                    // how long since task started?\n                    var duration = (now.getTime() - this.task.startTime.getTime());\n                    // how long since last active?\n                    var lastActive = (now.getTime() - this.lastActive.getTime());\n\n                    if (this.task.timeLimit && // has a timelimit\n                        (duration > this.task.timeLimit) && // timelimit is up\n                        (lastActive > this.task.timeLimit) // nobody has typed for 60 seconds at least\n                    ) {\n\n                        if (this.threads.timeout) {\n                            this.status = 'ending';\n                            this.gotoThread('timeout');\n                        } else {\n                            this.stop('timeout');\n                        }\n                    }\n                    // otherwise do nothing\n                } else {\n                    if (this.messages.length) {\n\n                        if (this.sent.length &&\n                            !this.sent[this.sent.length - 1].sent\n                        ) {\n                            return;\n                        }\n\n                        if (this.task.bot.botkit.config.require_delivery &&\n                            this.sent.length &&\n                            !this.sent[this.sent.length - 1].delivered\n                        ) {\n                            return;\n                        }\n\n                        if (typeof(this.messages[0].timestamp) == 'undefined' ||\n                            this.messages[0].timestamp <= now.getTime()) {\n                            var message = this.messages.shift();\n                            //console.log('HANDLING NEW MESSAGE',message);\n                            // make sure next message is delayed appropriately\n                            if (this.messages.length && this.messages[0].delay) {\n                                this.messages[0].timestamp = now.getTime() + this.messages[0].delay;\n                            }\n                            if (message.handler) {\n                                //console.log(\">>>>>> SET HANDLER IN TICK\");\n                                this.handler = message.handler;\n                            } else {\n                                this.handler = null;\n                                //console.log(\">>>>>>> CLEARING HANDLER BECAUSE NO HANDLER NEEDED\");\n                            }\n                            if (message.capture_options) {\n                                this.capture_options = message.capture_options;\n                            } else {\n                                this.capture_options = {};\n                            }\n\n                            this.lastActive = new Date();\n\n                            // is there any text?\n                            // or an attachment? (facebook)\n                            // or multiple attachments (slack)\n                            if (message.text || message.attachments || message.attachment) {\n\n                                var outbound = this.cloneMessage(message);\n                                var that = this;\n\n                                outbound.sent_timestamp = new Date().getTime();\n\n                                that.sent.push(outbound);\n                                that.transcript.push(outbound);\n\n                                this.task.bot.reply(this.source_message, outbound, function(err, sent_message) {\n                                    if (err) {\n                                        botkit.log('An error occurred while sending a message: ', err);\n\n                                        // even though an error occured, set sent to true\n                                        // this will allow the conversation to keep going even if one message fails\n                                        // TODO: make a message that fails to send _resend_ at least once\n                                        that.sent[that.sent.length - 1].sent = true;\n                                        that.sent[that.sent.length - 1].api_response = err;\n\n                                    } else {\n\n                                        that.sent[that.sent.length - 1].sent = true;\n                                        that.sent[that.sent.length - 1].api_response = sent_message;\n\n                                        // if sending via slack's web api, there is no further confirmation\n                                        // so we can mark the message delivered\n                                        if (that.task.bot.type == 'slack' && sent_message && sent_message.ts) {\n                                            that.sent[that.sent.length - 1].delivered = true;\n                                        }\n\n                                        that.trigger('sent', [sent_message]);\n\n                                    }\n                                });\n                            }\n                            if (message.action) {\n                                if (typeof(message.action) == 'function') {\n                                    message.action(this);\n                                } else if (message.action == 'repeat') {\n                                    this.repeat();\n                                } else if (message.action == 'wait') {\n                                    this.silentRepeat();\n                                } else if (message.action == 'stop') {\n                                    this.stop();\n                                } else if (message.action == 'timeout') {\n                                    this.stop('timeout');\n                                } else if (this.threads[message.action]) {\n                                    this.gotoThread(message.action);\n                                }\n                            }\n                        } else {\n                            //console.log('Waiting to send next message...');\n                        }\n\n                        // end immediately instad of waiting til next tick.\n                        // if it hasn't already been ended by a message action!\n                        if (this.isActive() && !this.messages.length && !this.handler) {\n                            this.stop('completed');\n                        }\n\n                    } else if (this.sent.length) { // sent at least 1 message\n                        this.stop('completed');\n                    }\n                }\n            }\n        };\n\n        botkit.debug('CREATED A CONVO FOR', this.source_message.user, this.source_message.channel);\n        this.gotoThread('default');\n    };\n\n    function Task(bot, message, botkit) {\n\n        this.convos = [];\n        this.botkit = botkit;\n        this.bot = bot;\n\n        this.events = {};\n        this.source_message = message;\n        this.status = 'active';\n        this.startTime = new Date();\n\n        this.isActive = function() {\n            return this.status == 'active';\n        };\n\n        this.createConversation = function(message) {\n            var convo = new Conversation(this, message);\n            convo.id = botkit.convoCount++;\n            this.convos.push(convo);\n            return convo;\n        };\n\n        this.startConversation = function(message) {\n\n            var convo = this.createConversation(message);\n            botkit.log('>   [Start] ', convo.id, ' Conversation with ', message.user, 'in', message.channel);\n\n            convo.activate();\n            return convo;\n        };\n\n        this.conversationEnded = function(convo) {\n            botkit.log('>   [End] ', convo.id, ' Conversation with ',\n                       convo.source_message.user, 'in', convo.source_message.channel);\n            this.trigger('conversationEnded', [convo]);\n            this.botkit.trigger('conversationEnded', [bot, convo]);\n            convo.trigger('end', [convo]);\n            var actives = 0;\n            for (var c = 0; c < this.convos.length; c++) {\n                if (this.convos[c].isActive()) {\n                    actives++;\n                }\n            }\n            if (actives == 0) {\n                this.taskEnded();\n            }\n\n        };\n\n        this.endImmediately = function(reason) {\n\n            for (var c = 0; c < this.convos.length; c++) {\n                if (this.convos[c].isActive()) {\n                    this.convos[c].stop(reason || 'stopped');\n                }\n            }\n\n        };\n\n        this.taskEnded = function() {\n            botkit.log('[End] ', this.id, ' Task for ',\n                this.source_message.user, 'in', this.source_message.channel);\n\n            this.status = 'completed';\n            this.trigger('end', [this]);\n\n        };\n\n        this.on = function(event, cb) {\n            botkit.debug('Setting up a handler for', event);\n            var events = event.split(/\\,/g);\n            for (var e in events) {\n                if (!this.events[events[e]]) {\n                    this.events[events[e]] = [];\n                }\n                this.events[events[e]].push(cb);\n            }\n            return this;\n        };\n\n        this.trigger = function(event, data) {\n            if (this.events[event]) {\n                for (var e = 0; e < this.events[event].length; e++) {\n                    var res = this.events[event][e].apply(this, data);\n                    if (res === false) {\n                        return;\n                    }\n                }\n            }\n        };\n\n\n        this.getResponsesByUser = function() {\n\n            var users = {};\n\n            // go through all conversations\n            // extract normalized answers\n            for (var c = 0; c < this.convos.length; c++) {\n\n                var user = this.convos[c].source_message.user;\n                users[this.convos[c].source_message.user] = {};\n                var convo = this.convos[c];\n                users[user] = convo.extractResponses();\n            }\n\n            return users;\n\n        };\n\n        this.getResponsesBySubject = function() {\n            var answers = {};\n\n            // go through all conversations\n            // extract normalized answers\n            for (var c = 0; c < this.convos.length; c++) {\n                var convo = this.convos[c];\n\n                for (var key in convo.responses) {\n                    if (!answers[key]) {\n                        answers[key] = {};\n                    }\n                    answers[key][convo.source_message.user] = convo.extractResponse(key);\n                }\n            }\n\n            return answers;\n        };\n\n        this.tick = function() {\n\n            for (var c = 0; c < this.convos.length; c++) {\n                if (this.convos[c].isActive()) {\n                    this.convos[c].tick();\n                }\n            }\n        };\n    };\n\n    botkit.storage = {\n        teams: {\n            get: function(team_id, cb) {\n                cb(null, botkit.memory_store.teams[team_id]);\n            },\n            save: function(team, cb) {\n                botkit.log('Warning: using temporary storage. Data will be lost when process restarts.');\n                if (team.id) {\n                    botkit.memory_store.teams[team.id] = team;\n                    cb(null, team.id);\n                } else {\n                    cb('No ID specified');\n                }\n            },\n            all: function(cb) {\n                cb(null, botkit.memory_store.teams);\n            }\n        },\n        users: {\n            get: function(user_id, cb) {\n                cb(null, botkit.memory_store.users[user_id]);\n            },\n            save: function(user, cb) {\n                botkit.log('Warning: using temporary storage. Data will be lost when process restarts.');\n                if (user.id) {\n                    botkit.memory_store.users[user.id] = user;\n                    cb(null, user.id);\n                } else {\n                    cb('No ID specified');\n                }\n            },\n            all: function(cb) {\n                cb(null, botkit.memory_store.users);\n            }\n        },\n        channels: {\n            get: function(channel_id, cb) {\n                cb(null, botkit.memory_store.channels[channel_id]);\n            },\n            save: function(channel, cb) {\n                botkit.log('Warning: using temporary storage. Data will be lost when process restarts.');\n                if (channel.id) {\n                    botkit.memory_store.channels[channel.id] = channel;\n                    cb(null, channel.id);\n                } else {\n                    cb('No ID specified');\n                }\n            },\n            all: function(cb) {\n                cb(null, botkit.memory_store.channels);\n            }\n        }\n    };\n\n\n    /**\n     * hears_regexp - default string matcher uses regular expressions\n     *\n     * @param  {array}  tests    patterns to match\n     * @param  {object} message message object with various fields\n     * @return {boolean}        whether or not a pattern was matched\n     */\n    botkit.hears_regexp = function(tests, message) {\n        for (var t = 0; t < tests.length; t++) {\n            if (message.text) {\n\n                // the pattern might be a string to match (including regular expression syntax)\n                // or it might be a prebuilt regular expression\n                var test = null;\n                if (typeof(tests[t]) == 'string') {\n                    try {\n                        test = new RegExp(tests[t], 'i');\n                    } catch (err) {\n                        botkit.log('Error in regular expression: ' + tests[t] + ': ' + err);\n                        return false;\n                    }\n                    if (!test) {\n                        return false;\n                    }\n                } else {\n                    test = tests[t];\n                }\n\n                if (match = message.text.match(test)) {\n                    message.match = match;\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n\n    /**\n     * changeEars - change the default matching function\n     *\n     * @param  {function} new_test a function that accepts (tests, message) and returns a boolean\n     */\n    botkit.changeEars = function(new_test) {\n        botkit.hears_test = new_test;\n    };\n\n\n    botkit.hears = function(keywords, events, middleware_or_cb, cb) {\n\n        // the third parameter is EITHER a callback handler\n        // or a middleware function that redefines how the hear works\n        var test_function = botkit.hears_test;\n        if (cb) {\n            test_function = middleware_or_cb;\n        } else {\n            cb = middleware_or_cb;\n        }\n\n        if (typeof(keywords) == 'string') {\n            keywords = [keywords];\n        }\n        if (typeof(events) == 'string') {\n            events = events.split(/\\,/g);\n        }\n\n        for (var e = 0; e < events.length; e++) {\n            (function(keywords, test_function) {\n                botkit.on(events[e], function(bot, message) {\n                    if (test_function && test_function(keywords, message)) {\n                        botkit.debug('I HEARD', keywords);\n                        botkit.middleware.heard.run(bot, message, function(err, bot, message) {\n                            cb.apply(this, [bot, message]);\n                            botkit.trigger('heard_trigger', [bot, keywords, message]);\n                        });\n                        return false;\n                    }\n                });\n            })(keywords, test_function);\n        }\n\n        return this;\n    };\n\n    botkit.on = function(event, cb) {\n        botkit.debug('Setting up a handler for', event);\n        var events = (typeof(event) == 'string') ? event.split(/\\,/g) : event;\n\n        for (var e in events) {\n            if (!this.events[events[e]]) {\n                this.events[events[e]] = [];\n            }\n            this.events[events[e]].push(cb);\n        }\n        return this;\n    };\n\n    botkit.trigger = function(event, data) {\n        if (this.events[event]) {\n            for (var e = 0; e < this.events[event].length; e++) {\n                var res = this.events[event][e].apply(this, data);\n                if (res === false) {\n                    return;\n                }\n            }\n        }\n    };\n\n    botkit.startConversation = function(bot, message, cb) {\n        botkit.startTask(bot, message, function(task, convo) {\n            cb(null, convo);\n        });\n    };\n\n    botkit.createConversation = function(bot, message, cb) {\n\n        var task = new Task(bot, message, this);\n\n        task.id = botkit.taskCount++;\n\n        var convo = task.createConversation(message);\n\n        this.tasks.push(task);\n\n        cb(null, convo);\n\n    };\n\n\n    botkit.defineBot = function(unit) {\n        if (typeof(unit) != 'function') {\n            throw new Error('Bot definition must be a constructor function');\n        }\n        this.worker = unit;\n    };\n\n    botkit.spawn = function(config, cb) {\n\n\n        var worker = new this.worker(this, config);\n        // mutate the worker so that we can call middleware\n        worker.say = function(message, cb) {\n            botkit.middleware.send.run(worker, message, function(err, worker, message) {\n                if (err) {\n                    botkit.log('Error in worker.say: ' + err);\n                } else {\n                    worker.send(message, cb);\n                }\n            });\n        };\n        botkit.middleware.spawn.run(worker, function(err, worker) {\n            if (err) {\n                botkit.log('Error in middlware.spawn.run: ' + err);\n            } else {\n                botkit.trigger('spawned', [worker]);\n\n                if (cb) { cb(worker); }\n            }\n        });\n\n        return worker;\n    };\n\n    botkit.startTicking = function() {\n        if (!botkit.tickInterval) {\n            // set up a once a second tick to process messages\n            botkit.tickInterval = setInterval(function() {\n                botkit.tick();\n            }, 1500);\n        }\n    };\n\n    botkit.shutdown = function() {\n        if (botkit.tickInterval) {\n            clearInterval(botkit.tickInterval);\n        }\n    };\n\n    botkit.startTask = function(bot, message, cb) {\n\n\n        var task = new Task(bot, message, this);\n\n        task.id = botkit.taskCount++;\n        botkit.log('[Start] ', task.id, ' Task for ', message.user, 'in', message.channel);\n\n        var convo = task.startConversation(message);\n\n        this.tasks.push(task);\n\n        if (cb) {\n            cb(task, convo);\n        } else {\n            return task;\n        }\n\n    };\n\n    botkit.receiveMessage = function(bot, message) {\n        botkit.middleware.receive.run(bot, message, function(err, bot, message) {\n            if (err) {\n                botkit.log('ERROR IN RECEIVE MIDDLEWARE: ', err);\n            } else {\n                botkit.debug('RECEIVED MESSAGE');\n                bot.findConversation(message, function(convo) {\n                    if (convo) {\n                        convo.handle(message);\n                    } else {\n                        botkit.trigger('message_received', [bot, message]);\n                    }\n                });\n            }\n        });\n    };\n\n    botkit.tick = function() {\n        for (var t = 0; t < botkit.tasks.length; t++) {\n            botkit.tasks[t].tick();\n        }\n        for (var t = botkit.tasks.length - 1; t >= 0; t--) {\n            if (!botkit.tasks[t].isActive()) {\n                botkit.tasks.splice(t, 1);\n            }\n        }\n\n\n        this.trigger('tick', []);\n\n    };\n\n\n    /**\n     * Define a default worker bot. This function should be customized outside\n     * of Botkit and passed in as a parameter by the developer\n     **/\n    botkit.worker = function(botkit, config) {\n        this.botkit = botkit;\n        this.config = config;\n\n        this.say = function(message, cb) {\n            botkit.debug('SAY:', message);\n        };\n\n        this.replyWithQuestion = function(message, question, cb) {\n\n            botkit.startConversation(message, function(convo) {\n                convo.ask(question, cb);\n            });\n\n        };\n\n        this.reply = function(src, resp) {\n            botkit.debug('REPLY:', resp);\n        };\n\n\n        this.findConversation = function(message, cb) {\n            botkit.debug('DEFAULT FIND CONVO');\n            cb(null);\n        };\n    };\n\n    botkit.userAgent = function() {\n\n        if (!botkit.my_user_agent) {\n            // set user agent to Botkit\n            var ua = 'Botkit/' + botkit.version();\n\n            // add OS info\n            ua = ua + ' ' + os.platform() + '/' + os.release();\n\n            // add Node info\n            ua = ua + ' ' + 'node/' + process.version.replace('v', '');\n\n            botkit.my_user_agent = ua;\n        }\n\n        return botkit.my_user_agent;\n\n    };\n\n\n    botkit.version = function() {\n\n        if (!botkit.my_version) {\n            var pkg = fs.readFileSync(__dirname + '/../package.json');\n            try {\n                pkg = JSON.parse(pkg);\n            } catch (err) {\n                throw new Error('Could not determine Botkit version', err);\n            }\n\n            botkit.my_version = pkg.version;\n        }\n        return botkit.my_version;\n\n    };\n\n\n    botkit.config = configuration;\n\n    /** Default the application to listen to the 0.0.0.0, the default\n      * for node's http module. Developers can specify a hostname or IP\n      * address to override this.\n    **/\n    if (!botkit.config.hostname) {\n        botkit.config.hostname = '0.0.0.0';\n    };\n\n\n    if (!configuration.logLevel) {\n        if (configuration.debug) {\n            configuration.logLevel = 'debug';\n        } else if (configuration.log === false) {\n            configuration.logLevel = 'error';\n        } else {\n            configuration.logLevel = 'info';\n        }\n    }\n\n    if (configuration.logger) {\n        if (typeof configuration.logger.log === 'function') {\n            botkit.logger = configuration.logger;\n        } else {\n            throw new Error('Logger object does not have a `log` method!');\n        }\n    } else {\n        botkit.logger = ConsoleLogger(console, configuration.logLevel);\n    }\n\n    botkit.log = function() {\n        botkit.log.info.apply(botkit.log, arguments);\n    };\n    Object.keys(LogLevels).forEach(function(level) {\n        botkit.log[level] = botkit.logger.log.bind(botkit.logger, level);\n    });\n    botkit.debug = botkit.log.debug;\n\n    console.log('Initializing Botkit v' + botkit.version());\n\n    if (configuration.storage) {\n        if (\n            configuration.storage.teams &&\n            configuration.storage.teams.get &&\n            configuration.storage.teams.save &&\n\n            configuration.storage.users &&\n            configuration.storage.users.get &&\n            configuration.storage.users.save &&\n\n            configuration.storage.channels &&\n            configuration.storage.channels.get &&\n            configuration.storage.channels.save\n        ) {\n            botkit.log('** Using custom storage system.');\n            botkit.storage = configuration.storage;\n        } else {\n            throw new Error('Storage object does not have all required methods!');\n        }\n    } else if (configuration.json_file_store) {\n        botkit.log('** Using simple storage. Saving data to ' + configuration.json_file_store);\n        botkit.storage = simple_storage({path: configuration.json_file_store});\n    } else {\n        botkit.log('** No persistent storage method specified! Data may be lost when process shuts down.');\n    }\n\n    // set the default set of ears to use the regular expression matching\n    botkit.changeEars(botkit.hears_regexp);\n\n    //enable Botkit Studio\n    studio(botkit);\n\n    return botkit;\n}\n\nmodule.exports = Botkit;\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/storage/simple_storage.js":"/*\nStorage module for bots.\n\nSupports storage of data on a team-by-team, user-by-user, and chnnel-by-channel basis.\n\nsave can be used to store arbitrary object.\nThese objects must include an id by which they can be looked up.\nIt is recommended to use the team/user/channel id for this purpose.\nExample usage of save:\ncontroller.storage.teams.save({id: message.team, foo:\"bar\"}, function(err){\n  if (err)\n    console.log(err)\n});\n\nget looks up an object by id.\nExample usage of get:\ncontroller.storage.teams.get(message.team, function(err, team_data){\n  if (err)\n    console.log(err)\n  else\n    console.log(team_data)\n});\n*/\n\nvar Store = require('jfs');\n\nmodule.exports = function(config) {\n\n    if (!config) {\n        config = {\n            path: './',\n        };\n    }\n\n    var teams_db = new Store(config.path + '/teams', {saveId: 'id'});\n    var users_db = new Store(config.path + '/users', {saveId: 'id'});\n    var channels_db = new Store(config.path + '/channels', {saveId: 'id'});\n\n    var objectsToList = function(cb) {\n        return function(err, data) {\n            if (err) {\n                cb(err, data);\n            } else {\n                cb(err, Object.keys(data).map(function(key) {\n                    return data[key];\n                }));\n            }\n        };\n    };\n\n    var storage = {\n        teams: {\n            get: function(team_id, cb) {\n                teams_db.get(team_id, cb);\n            },\n            save: function(team_data, cb) {\n                teams_db.save(team_data.id, team_data, cb);\n            },\n            delete: function(team_id, cb) {\n                teams_db.delete(team_id.id, cb);\n            },\n            all: function(cb) {\n                teams_db.all(objectsToList(cb));\n            }\n        },\n        users: {\n            get: function(user_id, cb) {\n                users_db.get(user_id, cb);\n            },\n            save: function(user, cb) {\n                users_db.save(user.id, user, cb);\n            },\n            delete: function(user_id, cb) {\n                users_db.delete(user_id.id, cb);\n            },\n            all: function(cb) {\n                users_db.all(objectsToList(cb));\n            }\n        },\n        channels: {\n            get: function(channel_id, cb) {\n                channels_db.get(channel_id, cb);\n            },\n            save: function(channel, cb) {\n                channels_db.save(channel.id, channel, cb);\n            },\n            delete: function(channel_id, cb) {\n                channels_db.delete(channel_id.id, cb);\n            },\n            all: function(cb) {\n                channels_db.all(objectsToList(cb));\n            }\n        }\n    };\n\n    return storage;\n};\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/console_logger.js":"var slice = Array.prototype.slice;\n/**\n * RFC 5424 syslog severity levels, see\n * https://tools.ietf.org/html/rfc5424#section-6.2.1\n */\nvar levels = [\n    'emergency',\n    'alert',\n    'critical',\n    'error',\n    'warning',\n    'notice',\n    'info',\n    'debug'\n];\nvar levelsByName = levels.reduce(function(out, name, index) {\n    out[name] = index;\n    return out;\n}, {});\n\nfunction normalizeLogLevel(level) {\n    if (typeof level === 'string') {\n        level = levelsByName[level];\n    }\n    if (typeof level === 'number' && level >= 0 && level < levels.length) {\n        return level;\n    }\n    return false;\n}\n\nfunction ConsoleLogger(_console, maxLevel, defaultLevel) {\n    _console = _console || console;\n    maxLevel = normalizeLogLevel(maxLevel) || 6;\n    defaultLevel = normalizeLogLevel(defaultLevel) || 6;\n    return {\n        log: function(level, message) {\n            var normalizedLevel = normalizeLogLevel(level);\n            if (!normalizedLevel) {\n                message = level;\n                normalizedLevel = defaultLevel;\n            }\n            var levelName = levels[normalizedLevel];\n            if (normalizedLevel <= maxLevel) {\n                _console.log.apply(\n                    _console,\n                    [levelName + ': ' + message].concat(slice.call(arguments, 2))\n                );\n            }\n        }\n    };\n}\n\nConsoleLogger.LogLevels = levelsByName;\n\nmodule.exports = ConsoleLogger;\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/Studio.js":"var request = require('request');\nvar Promise = require('promise');\nvar md5 = require('md5');\nvar SDK = require('botkit-studio-sdk');\n\nmodule.exports = function(controller) {\n    var before_hooks = {};\n    var after_hooks = {};\n    var answer_hooks = {};\n\n\n    // define a place for the studio specific features to live.\n    controller.studio = {};\n\n    /* ----------------------------------------------------------------\n     * Botkit Studio Script Services\n     * The features in this section grant access to Botkit Studio's\n     * script and trigger services\n     * ---------------------------------------------------------------- */\n\n    function genConfig(bot) {\n         var config = {};\n\n         if (bot.config && bot.config.studio_token) {\n             config.studio_token = bot.config.studio_token;\n         }\n\n         if (bot.config && bot.config.studio_command_uri) {\n             config.studio_command_uri = bot.config.studio_command_uri;\n         }\n\n         if (controller.config && controller.config.studio_token) {\n             config.studio_token = controller.config.studio_token;\n         }\n\n         if (controller.config && controller.config.studio_command_uri) {\n             config.studio_command_uri = controller.config.studio_command_uri;\n         }\n\n         return config;\n     }\n\n    controller.studio.evaluateTrigger = function(bot, text, user) {\n\n        var userHash = md5(user);\n        var sdk = new SDK(genConfig(bot));\n        return sdk.evaluateTrigger(text, userHash);\n\n    };\n\n\n\n\n    // load a script from the pro service\n    controller.studio.getScript = function(bot, text, user) {\n\n        var userHash = md5(user);\n        var sdk = new SDK(genConfig(bot));\n        return sdk.getScript(text, user);\n    };\n\n\n    // these are middleware functions\n    controller.studio.validate = function(command_name, key, func) {\n\n        if (!answer_hooks[command_name]) {\n            answer_hooks[command_name] = [];\n\n        }\n        if (key && !answer_hooks[command_name][key]) {\n            answer_hooks[command_name][key] = [];\n            answer_hooks[command_name][key].push(func);\n        }\n\n        return controller.studio;\n    };\n\n    controller.studio.before = function(command_name, func) {\n\n        if (!before_hooks[command_name]) {\n            before_hooks[command_name] = [];\n        }\n\n        before_hooks[command_name].push(func);\n\n        return controller.studio;\n    };\n\n    controller.studio.after = function(command_name, func) {\n\n        if (!after_hooks[command_name]) {\n            after_hooks[command_name] = [];\n        }\n\n        after_hooks[command_name].push(func);\n\n        return controller.studio;\n\n    };\n\n    function runHooks(hooks, convo, cb) {\n\n        if (!hooks || !hooks.length) {\n            return cb(convo);\n        }\n\n        var func = hooks.shift();\n\n        func(convo, function() {\n            if (hooks.length) {\n                runHooks(hooks, convo, cb);\n            } else {\n                return cb(convo);\n            }\n        });\n    }\n\n\n    /* Fetch a script from Botkit Studio by name, then execute it.\n     * returns a promise that resolves when the conversation is loaded and active */\n    controller.studio.run = function(bot, input_text, user, channel) {\n\n        return new Promise(function(resolve, reject) {\n\n            controller.studio.get(bot, input_text, user, channel).then(function(convo) {\n                convo.activate();\n                resolve(convo);\n            }).catch(function(err) {\n                reject(err);\n            });\n        });\n\n    };\n\n    /* Fetch a script from Botkit Studio by name, but do not execute it.\n     * returns a promise that resolves when the conversation is loaded\n     * but developer still needs to call convo.activate() to put it in motion */\n    controller.studio.get = function(bot, input_text, user, channel) {\n        var context = {\n            text: input_text,\n            user: user,\n            channel: channel,\n        };\n        return new Promise(function(resolve, reject) {\n            controller.studio.getScript(bot, input_text, user).then(function(command) {\n                controller.trigger('command_triggered', [bot, context, command]);\n                controller.studio.compileScript(\n                    bot,\n                    context,\n                    command.command,\n                    command.script,\n                    command.variables\n                ).then(function(convo) {\n                    convo.on('end', function(convo) {\n                        runHooks(\n                            after_hooks[command.command] ? after_hooks[command.command].slice() : [],\n                            convo,\n                            function(convo) {\n                                controller.trigger('remote_command_end', [bot, context, command, convo]);\n                            }\n                        );\n                    });\n                    runHooks(\n                        before_hooks[command.command] ? before_hooks[command.command].slice() : [],\n                        convo,\n                        function(convo) {\n                            resolve(convo);\n                        }\n                    );\n                }).catch(function(err) {\n                    reject(err);\n                });\n            });\n        });\n    };\n\n\n    controller.studio.runTrigger = function(bot, input_text, user, channel) {\n        var context = {\n            text: input_text,\n            user: user,\n            channel: channel,\n        };\n        return new Promise(function(resolve, reject) {\n            controller.studio.evaluateTrigger(bot, input_text, user).then(function(command) {\n                if (command !== {} && command.id) {\n                    controller.trigger('command_triggered', [bot, context, command]);\n                    controller.studio.compileScript(\n                        bot,\n                        context,\n                        command.command,\n                        command.script,\n                        command.variables\n                    ).then(function(convo) {\n\n                        convo.on('end', function(convo) {\n                            runHooks(\n                                after_hooks[command.command] ? after_hooks[command.command].slice() : [],\n                                convo,\n                                function(convo) {\n                                    controller.trigger('remote_command_end', [bot, context, command, convo]);\n                                }\n                            );\n                        });\n\n                        runHooks(\n                            before_hooks[command.command] ? before_hooks[command.command].slice() : [],\n                            convo,\n                            function(convo) {\n                                convo.activate();\n                                resolve(convo);\n                            }\n                        );\n                    }).catch(function(err) {\n                        reject(err);\n                    });\n                } else {\n                    // return with no conversation\n                    // allow developer to run a default script\n                    resolve(null);\n                }\n            }).catch(function(err) {\n                reject(err);\n            });\n        });\n\n    };\n\n\n    controller.studio.testTrigger = function(bot, input_text, user, channel) {\n        var context = {\n            text: input_text,\n            user: user,\n            channel: channel,\n        };\n        return new Promise(function(resolve, reject) {\n            controller.studio.evaluateTrigger(bot, input_text, user).then(function(command) {\n                if (command !== {} && command.id) {\n                    resolve(true);\n                } else {\n                    resolve(false);\n                }\n            }).catch(function(err) {\n                reject(err);\n            });\n        });\n\n    };\n\n    controller.studio.compileScript = function(bot, message, command_name, topics, vars) {\n        function makeHandler(options, field) {\n            var pattern = '';\n\n            if (options.type == 'utterance') {\n                pattern = controller.utterances[options.pattern];\n            } else if (options.type == 'string') {\n                pattern = '^' + options.pattern + '$';\n            } else if (options.type == 'regex') {\n                pattern = options.pattern;\n            }\n\n            return {\n                pattern: pattern,\n                default: options.default,\n                callback: function(response, convo) {\n                    var hooks = [];\n                    if (field.key && answer_hooks[command_name] && answer_hooks[command_name][field.key]) {\n                        hooks = answer_hooks[command_name][field.key].slice();\n                    }\n                    if (options.action != 'wait' && field.multiple) {\n                        convo.responses[field.key].pop();\n                    }\n\n                    runHooks(hooks, convo, function(convo) {\n                        switch (options.action) {\n                            case 'next':\n                                convo.next();\n                                break;\n                            case 'repeat':\n                                // before continuing, repeat the last send message\n                                // use sayFirst, so that it prepends it to the front of script\n                                convo.sayFirst(convo.sent[convo.sent.length - 1]);\n                                convo.next();\n                                break;\n                            case 'stop':\n                                convo.stop();\n                                break;\n                            case 'wait':\n                                convo.silentRepeat();\n                                break;\n                            default:\n                                convo.changeTopic(options.action);\n                                break;\n                        }\n                    });\n                }\n            };\n\n        }\n\n        return new Promise(function(resolve, reject) {\n            bot.createConversation(message, function(err, convo) {\n\n                convo.setTimeout(controller.config.default_timeout || (15 * 60 * 1000)); // 15 minute default timeout\n                if (err) {\n                    return reject(err);\n                }\n                for (var t = 0; t < topics.length; t++) {\n                    var topic = topics[t].topic;\n                    for (var m = 0; m < topics[t].script.length; m++) {\n\n                        var message = {};\n\n                        if (topics[t].script[m].text) {\n                            message.text = topics[t].script[m].text;\n                        }\n\n                        // handle Slack attachments\n                        if (topics[t].script[m].attachments) {\n                            message.attachments = topics[t].script[m].attachments;\n\n\n                            // enable mrkdwn formatting in all fields of the attachment\n                            for (var a = 0; a < message.attachments.length; a++) {\n                                message.attachments[a].mrkdwn_in = ['text', 'pretext', 'fields'];\n                                message.attachments[a].mrkdwn = true;\n                            }\n                        }\n\n                        // handle Facebook attachments\n                        if (topics[t].script[m].fb_attachment) {\n                            var attachment = topics[t].script[m].fb_attachment;\n                            if (attachment.template_type) {\n                                if (attachment.template_type == 'button') {\n                                    attachment.text = message.text;\n                                }\n                                message.attachment = {\n                                    type: 'template',\n                                    payload: attachment\n                                };\n                            } else if (attachment.type) {\n                                message.attachment = attachment;\n                            }\n\n                            // blank text, not allowed with attachment\n                            message.text = null;\n\n                        }\n\n                        // handle Facebook quick replies\n                        if (topics[t].script[m].quick_replies) {\n                            var options = topics[t].script[m].quick_replies;\n                            if (!message.quick_replies) {\n                                message.quick_replies = [];\n                            }\n                            for (var o = 0; o < options.length; o++) {\n                                message.quick_replies.push(options[o]);\n                            }\n                        }\n\n                        // handle Facebook quick replies that are embedded in question options\n                        if (topics[t].script[m].collect) {\n\n                            var options = topics[t].script[m].collect.options || [];\n                            if (options.length > 0) {\n                                for (var o = 0; o < options.length; o++) {\n                                    if (options[o].fb_quick_reply) {\n                                        if (!message.quick_replies) {\n                                            message.quick_replies = [];\n                                        }\n                                        message.quick_replies.push({\n                                            title: options[o].pattern,\n                                            payload: options[o].fb_quick_reply_payload,\n                                            image_url: options[o].fb_quick_reply_image_url,\n                                            content_type: options[o].fb_quick_reply_content_type,\n                                        });\n                                    }\n                                }\n                            }\n                        }\n\n                        if (topics[t].script[m].action) {\n                            message.action = topics[t].script[m].action;\n                        }\n\n                        if (topics[t].script[m].collect) {\n                            // this is a question message\n                            var capture_options = {};\n                            var handlers = [];\n                            var options = topics[t].script[m].collect.options || [];\n                            if (topics[t].script[m].collect.key) {\n                                capture_options.key = topics[t].script[m].collect.key;\n                            }\n\n                            if (topics[t].script[m].collect.multiple) {\n                                capture_options.multiple = true;\n                            }\n\n                            var default_found = false;\n                            for (var o = 0; o < options.length; o++) {\n                                var handler = makeHandler(options[o], capture_options);\n                                handlers.push(handler);\n                                if (options[o].default) {\n                                    default_found = true;\n                                }\n                            }\n\n                            // make sure there is a default\n                            if (!default_found) {\n                                handlers.push({\n                                    default: true,\n                                    callback: function(r, c) {\n\n                                        runHooks(\n                                            answer_hooks[command_name] ? answer_hooks[command_name].slice() : [],\n                                            convo,\n                                            function(convo) {\n                                                c.next();\n                                            }\n                                        );\n                                    }\n                                });\n                            }\n\n                            convo.addQuestion(message, handlers, capture_options, topic);\n\n                        } else {\n\n                            // this is a simple message\n                            convo.addMessage(message, topic);\n                        }\n                    }\n                }\n                resolve(convo);\n            });\n        });\n    };\n\n    /* ----------------------------------------------------------------\n     * Botkit Studio Stats\n     * The features below this line pertain to communicating with Botkit Studio's\n     * stats feature.\n     * ---------------------------------------------------------------- */\n\n\n\n    function statsAPI(bot, options, message) {\n        var _STUDIO_STATS_API = controller.config.studio_stats_uri || 'https://stats.botkit.ai';\n        options.uri = _STUDIO_STATS_API + '/api/v1/stats';\n\n        return new Promise(function(resolve, reject) {\n\n            var headers = {\n                'content-type': 'application/json',\n            };\n\n            if (bot.config && bot.config.studio_token) {\n                options.uri = options.uri + '?access_token=' + bot.config.studio_token;\n            } else if (controller.config && controller.config.studio_token) {\n                options.uri = options.uri + '?access_token=' + controller.config.studio_token;\n            } else {\n                // console.log('DEBUG: Making an unathenticated request to stats api');\n            }\n\n            options.headers = headers;\n            var now = new Date();\n            if (options.now) {\n                now = options.now;\n            }\n\n\n            var stats_body = {};\n            stats_body.botHash = botHash(bot);\n            if (bot.type == 'slack' && bot.team_info) {\n                stats_body.team = md5(bot.team_info.id);\n            }\n\n            if (bot.type == 'ciscospark' && message && message.original_message && message.original_message.orgId) {\n                stats_body.team = md5(message.original_message.orgId);\n            }\n\n\n            stats_body.channel = options.form.channel;\n            stats_body.user = options.form.user;\n            stats_body.type = options.form.type;\n            stats_body.time = now;\n            stats_body.meta = {};\n            stats_body.meta.user = options.form.user;\n            stats_body.meta.channel = options.form.channel;\n            if (options.form.final_thread) {\n                stats_body.meta.final_thread = options.form.final_thread;\n            }\n            if (bot.botkit.config.clientId) {\n                stats_body.meta.app = md5(bot.botkit.config.clientId);\n            }\n            stats_body.meta.timestamp = options.form.timestamp;\n            stats_body.meta.bot_type = options.form.bot_type;\n            stats_body.meta.conversation_length = options.form.conversation_length;\n            stats_body.meta.status = options.form.status;\n            stats_body.meta.type = options.form.type;\n            stats_body.meta.command = options.form.command;\n            options.form = stats_body;\n            stats_body.meta.timestamp = options.now || now;\n            request(options, function(err, res, body) {\n                if (err) {\n                    console.log('Error in Botkit Studio Stats:', err);\n                    return reject(err);\n                }\n\n                var json = null;\n                try {\n                    json = JSON.parse(body);\n                } catch (e) {\n                    console.log('Error in Botkit Studio Stats:', e);\n                    return reject('Invalid JSON');\n                }\n\n                if (!json || json == null) {\n                    console.log('Error in Botkit Studio Stats: Response from Botkit Studio API was empty or invalid JSON');\n                    return reject('Response from Botkit Studio API was empty or invalid JSON');\n                } else if (json.error) {\n                    console.log('Error in Botkit Studio Stats:', json.error);\n                    return reject(json.error);\n                } else {\n                    resolve(json);\n                }\n\n            });\n        });\n    }\n\n    /* generate an anonymous hash to uniquely identify this bot instance */\n    function botHash(bot) {\n        var x = '';\n        switch (bot.type) {\n            case 'slack':\n                if (bot.config.token) {\n                    x = md5(bot.config.token);\n                } else {\n                    x = 'non-rtm-bot';\n                }\n                break;\n\n            case 'fb':\n                x = md5(bot.botkit.config.access_token);\n                break;\n\n            case 'twilioipm':\n                x = md5(bot.config.TWILIO_IPM_SERVICE_SID);\n                break;\n\n            case 'ciscospark':\n                x = md5(bot.botkit.config.ciscospark_access_token);\n                break;\n\n            default:\n                x = 'unknown-bot-type';\n                break;\n        }\n        return x;\n    };\n\n\n    /* Every time a bot spawns, Botkit calls home to identify this unique bot\n     * so that the maintainers of Botkit can measure the size of the installed\n     * userbase of Botkit-powered bots. */\n    if (!controller.config.stats_optout) {\n\n        controller.on('spawned', function(bot) {\n\n            var data = {\n                type: 'spawn',\n                bot_type: bot.type,\n            };\n            controller.trigger('stats:spawned', bot);\n            return statsAPI(bot, {\n                method: 'post',\n                form: data,\n            });\n        });\n\n\n        controller.on('heard_trigger', function(bot, keywords, message) {\n            var data = {\n                type: 'heard_trigger',\n                user: md5(message.user),\n                channel: md5(message.channel),\n                bot_type: bot.type,\n            };\n            controller.trigger('stats:heard_trigger', message);\n            return statsAPI(bot, {\n                method: 'post',\n                form: data,\n            }, message);\n        });\n\n        controller.on('command_triggered', function(bot, message, command) {\n            var data = {\n                type: 'command_triggered',\n                now: message.now,\n                user: md5(message.user),\n                channel: md5(message.channel),\n                command: command.command,\n                timestamp: command.created,\n                bot_type: bot.type,\n            };\n            controller.trigger('stats:command_triggered', message);\n            return statsAPI(bot, {\n                method: 'post',\n                form: data,\n            }, message);\n        });\n\n        controller.on('remote_command_end', function(bot, message, command, convo) {\n            var data = {\n                now: message.now,\n                user: md5(message.user),\n                channel: md5(message.channel),\n                command: command.command,\n                timestamp: command.created,\n                conversation_length: convo.lastActive - convo.startTime,\n                status: convo.status,\n                type: 'remote_command_end',\n                final_thread: convo.thread,\n                bot_type: bot.type,\n            };\n            controller.trigger('stats:remote_command_end', message);\n            return statsAPI(bot, {\n                method: 'post',\n                form: data,\n            }, message);\n\n        });\n\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/SlackBot.js":"var Botkit = require(__dirname + '/CoreBot.js');\nvar request = require('request');\nvar express = require('express');\nvar bodyParser = require('body-parser');\nvar querystring = require('querystring');\nvar async = require('async');\n\nfunction Slackbot(configuration) {\n\n    // Create a core botkit bot\n    var slack_botkit = Botkit(configuration || {});\n\n    // Set some default configurations unless they've already been set.\n\n    // Should the RTM connections ingest received messages\n    // Developers using the new Events API will set this to false\n    // This allows an RTM connection to be kept alive (so bot appears online)\n    // but receive messages only via events api\n    if (slack_botkit.config.rtm_receive_messages === undefined) {\n        slack_botkit.config.rtm_receive_messages = true;\n    }\n\n    var spawned_bots = [];\n\n    // customize the bot definition, which will be used when new connections\n    // spawn!\n    slack_botkit.defineBot(require(__dirname + '/Slackbot_worker.js'));\n\n    // Middleware to track spawned bots and connect existing RTM bots to incoming webhooks\n    slack_botkit.middleware.spawn.use(function(worker, next) {\n\n        // lets first check and make sure we don't already have a bot\n        // for this team! If we already have an RTM connection, copy it\n        // into the new bot so it can be used for replies.\n\n        var existing_bot = null;\n        if (worker.config.id) {\n            for (var b = 0; b < spawned_bots.length; b++) {\n                if (spawned_bots[b].config.id) {\n                    if (spawned_bots[b].config.id == worker.config.id) {\n                        // WAIT! We already have a bot spawned here.\n                        // so instead of using the new one, use the exist one.\n                        existing_bot = spawned_bots[b];\n                    }\n                }\n            }\n        }\n\n        if (!existing_bot && worker.config.id) {\n            spawned_bots.push(worker);\n        } else if (existing_bot) {\n            if (existing_bot.rtm) {\n                worker.rtm = existing_bot.rtm;\n            }\n        }\n        next();\n\n    });\n\n\n\n    // set up configuration for oauth\n    // slack_app_config should contain\n    // { clientId, clientSecret, scopes}\n    // https://api.slack.com/docs/oauth-scopes\n    slack_botkit.configureSlackApp = function(slack_app_config, cb) {\n\n        slack_botkit.log('** Configuring app as a Slack App!');\n        if (!slack_app_config || !slack_app_config.clientId ||\n            !slack_app_config.clientSecret || !slack_app_config.scopes) {\n            throw new Error('Missing oauth config details');\n        } else {\n            slack_botkit.config.clientId = slack_app_config.clientId;\n            slack_botkit.config.clientSecret = slack_app_config.clientSecret;\n            if (slack_app_config.redirectUri) slack_botkit.config.redirectUri = slack_app_config.redirectUri;\n            if (typeof(slack_app_config.scopes) == 'string') {\n                slack_botkit.config.scopes = slack_app_config.scopes.split(/\\,/);\n            } else {\n                slack_botkit.config.scopes = slack_app_config.scopes;\n            }\n            if (cb) cb(null);\n        }\n\n        return slack_botkit;\n\n    };\n\n    // set up a web route that is a landing page\n    slack_botkit.createHomepageEndpoint = function(webserver) {\n\n        slack_botkit.log('** Serving app landing page at : http://' +\n            slack_botkit.config.hostname + ':' + slack_botkit.config.port + '/');\n\n        // FIX THIS!!!\n        // this is obvs not right.\n        webserver.get('/', function(req, res) {\n\n            res.send('Howdy!');\n\n        });\n\n        return slack_botkit;\n\n    };\n\n\n    // adds the webhook authentication middleware module to the webserver\n    function secureWebhookEndpoints() {\n        var authenticationMiddleware = require(__dirname + '/middleware/slack_authentication.js');\n        // convert a variable argument list to an array, drop the webserver argument\n        var tokens = Array.prototype.slice.call(arguments);\n        var webserver = tokens.shift();\n\n        slack_botkit.log(\n            '** Requiring token authentication for webhook endpoints for Slash commands ' +\n            'and outgoing webhooks; configured ' + tokens.length + ' token(s)'\n        );\n\n        webserver.use(authenticationMiddleware(tokens));\n    }\n\n    // set up a web route for receiving outgoing webhooks and/or slash commands\n    slack_botkit.createWebhookEndpoints = function(webserver, authenticationTokens) {\n\n        if (authenticationTokens !== undefined && arguments.length > 1 && arguments[1].length) {\n            secureWebhookEndpoints.apply(null, arguments);\n        }\n\n        slack_botkit.log(\n            '** Serving webhook endpoints for Slash commands and outgoing ' +\n            'webhooks at: http://' + slack_botkit.config.hostname + ':' + slack_botkit.config.port + '/slack/receive');\n        webserver.post('/slack/receive', function(req, res) {\n\n            // respond to Slack that the webhook has been received.\n            res.status(200);\n\n            // Now, pass the webhook into be processed\n            slack_botkit.handleWebhookPayload(req, res);\n\n        });\n\n        return slack_botkit;\n    };\n\n    slack_botkit.findAppropriateTeam = function(payload, cb) {\n\n        var found_team = null;\n\n        var team_id = payload.team_id || (payload.team && payload.team.id) || null;\n        slack_botkit.findTeamById(team_id, function(err, team) {\n            if (team) {\n                cb(err, team);\n            } else {\n                if (payload.authed_teams) {\n                    async.eachSeries(payload.authed_teams, function(team_id, next) {\n                        slack_botkit.findTeamById(team_id, function(err, team) {\n                            if (team) {\n                                found_team = team;\n                                next();\n                            } else {\n                                next(err);\n                            }\n                        });\n                    }, function(err) {\n                        if (!found_team) {\n                            cb(err);\n                        } else {\n                            cb(null, found_team);\n                        }\n                    });\n                }\n            }\n        });\n    };\n\n    slack_botkit.handleWebhookPayload = function(req, res) {\n\n        // is this an events api url handshake?\n        if (req.body.type === 'url_verification') {\n            slack_botkit.debug('Received url handshake');\n            res.json({ challenge: req.body.challenge });\n            return;\n        }\n\n        var payload = req.body;\n        if (payload.payload) {\n            payload = JSON.parse(payload.payload);\n        }\n\n        slack_botkit.findAppropriateTeam(payload, function(err, team) {\n            if (err) {\n                slack_botkit.log.error('Could not load team while processing webhook: ', err);\n                return;\n            } else if (!team) {\n                // if this is NOT a slack app, it is ok to spawn a generic bot\n                // this is only likely to happen with custom slash commands\n                if (!slack_botkit.config.clientId) {\n                    bot = slack_botkit.spawn({});\n                } else {\n                    return;\n                }\n            } else {\n                // spawn a bot\n                bot = slack_botkit.spawn(team);\n\n                // Identify the bot from either team storage or identifyBot()\n                bot.team_info = team;\n\n                // The bot identity is only used in handleEventsAPI during this flow\n                // Recent changes in Slack will break other integrations as they no longer\n                // require a bot and therefore Slack won't send the bot information.\n                if (payload.type === 'event_callback') {\n\n                    if (!team.bot) {\n                        slack_botkit.log.error('No bot identity found.');\n                        return;\n                    }\n\n                    bot.identity = {\n                        id: team.bot.user_id,\n                        name: team.bot.name\n                    };\n                }\n            }\n\n            bot.res = res;\n\n            if (payload.type === 'event_callback') {\n                // Receive messages and trigger events from the Events API\n                res.send('');\n                return handleEventsAPI(payload, bot);\n            } else if (payload.callback_id) {\n                // is this an interactive message callback?\n                res.send('');\n                return handleInteractiveMessage(payload, bot);\n            } else if (payload.command) {\n                // this is a slash command\n                return handleSlashCommand(payload, bot);\n            } else if (payload.trigger_word) {\n                return handleOutgoingWebhook(payload, bot);\n            }\n        });\n    };\n\n    /* Handler functions for the various ways Slack might send a message to\n     * Botkit via webhooks.  These include interactive messages (button clicks),\n     * events api (messages sent over web hook), slash commands, and outgoing webhooks\n     * (patterns matched in slack that result in a webhook)\n     */\n    function handleInteractiveMessage(payload, bot) {\n\n        var message = {};\n        for (var key in payload) {\n            message[key] = payload[key];\n        }\n\n        // let's normalize some of these fields to match the rtm message format\n        message.user = message.user.id;\n        message.channel = message.channel.id;\n\n        // put the action value in the text field\n        // this allows button clicks to respond to asks\n        message.text = message.actions[0].value;\n\n        message.type = 'interactive_message_callback';\n\n        slack_botkit.trigger('interactive_message_callback', [bot, message]);\n\n        if (configuration.interactive_replies) {\n            message.type = 'message';\n            slack_botkit.receiveMessage(bot, message);\n        }\n    }\n\n    function handleEventsAPI(payload, bot) {\n\n        var message = {};\n        for (var key in payload.event) {\n            message[key] = payload.event[key];\n        }\n\n        // let's normalize some of these fields to match the rtm message format\n        message.team = payload.team_id;\n        message.events_api = true;\n        message.authed_users = payload.authed_users;\n\n        if (bot.identity == undefined || bot.identity.id == null) {\n            slack_botkit.log.error('Could not identify bot');\n            return;\n        } else if (bot.identity.id === message.user && message.subtype !== 'channel_join' && message.subtype !== 'group_join') {\n            slack_botkit.debug('Got event from this bot user, ignoring it');\n            return;\n        } else {\n            if (message.type === 'message') {\n                slack_botkit.receiveMessage(bot, message);\n            } else {\n                slack_botkit.trigger(message.type, [bot, message]);\n            }\n        }\n    };\n\n    function handleSlashCommand(payload, bot) {\n        var message = {};\n\n        for (var key in payload) {\n            message[key] = payload[key];\n        }\n\n        // let's normalize some of these fields to match the rtm message format\n        message.user = message.user_id;\n        message.channel = message.channel_id;\n\n        message.type = 'slash_command';\n\n        slack_botkit.receiveMessage(bot, message);\n    }\n\n    function handleOutgoingWebhook(payload, bot) {\n        var message = {};\n\n        for (var key in payload) {\n            message[key] = payload[key];\n        }\n\n        // let's normalize some of these fields to match the rtm message format\n        message.user = message.user_id;\n        message.channel = message.channel_id;\n\n        message.type = 'outgoing_webhook';\n\n        slack_botkit.receiveMessage(bot, message);\n    };\n\n    /* End of webhook handler functions\n     * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */\n\n    slack_botkit.saveTeam = function(team, cb) {\n        slack_botkit.storage.teams.save(team, cb);\n    };\n\n    // look up a team's memory and configuration and return it, or\n    // return an error!\n    slack_botkit.findTeamById = function(id, cb) {\n        slack_botkit.storage.teams.get(id, cb);\n    };\n\n    slack_botkit.setupWebserver = function(port, cb) {\n\n        if (!port) {\n            throw new Error('Cannot start webserver without a port');\n        }\n        if (isNaN(port)) {\n            throw new Error('Specified port is not a valid number');\n        }\n\n        var static_dir =  process.cwd() + '/public';\n\n        if (slack_botkit.config && slack_botkit.config.webserver && slack_botkit.config.webserver.static_dir)\n            static_dir = slack_botkit.config.webserver.static_dir;\n\n        slack_botkit.config.port = port;\n\n        slack_botkit.webserver = express();\n        slack_botkit.webserver.use(bodyParser.json());\n        slack_botkit.webserver.use(bodyParser.urlencoded({ extended: true }));\n        slack_botkit.webserver.use(express.static(static_dir));\n\n        var server = slack_botkit.webserver.listen(\n            slack_botkit.config.port,\n            slack_botkit.config.hostname,\n            function() {\n                slack_botkit.log('** Starting webserver on port ' +\n                    slack_botkit.config.port);\n                if (cb) { cb(null, slack_botkit.webserver); }\n            });\n\n        return slack_botkit;\n\n    };\n\n    // get a team url to redirect the user through oauth process\n    slack_botkit.getAuthorizeURL = function(team_id, redirect_params) {\n\n        var scopes = slack_botkit.config.scopes;\n        var api_root = slack_botkit.config.api_root ? slack_botkit.config.api_root : 'https://slack.com';\n\n        var url = api_root + '/oauth/authorize' + '?client_id=' +\n            slack_botkit.config.clientId + '&scope=' + scopes.join(',') + '&state=botkit';\n\n        if (team_id)\n            url += '&team=' + team_id;\n\n        if (slack_botkit.config.redirectUri) {\n            var redirect_query = '';\n            var redirect_uri = slack_botkit.config.redirectUri;\n            if (redirect_params) {\n                redirect_query += encodeURIComponent(querystring.stringify(redirect_params));\n                redirect_uri = redirect_uri + '?' + redirect_query;\n            }\n            url += '&redirect_uri=' + redirect_uri;\n        }\n\n        return url;\n\n    };\n\n    // set up a web route for redirecting users\n    // and collecting authentication details\n    // https://api.slack.com/docs/oauth\n    // https://api.slack.com/docs/oauth-scopes\n    slack_botkit.createOauthEndpoints = function(webserver, callback) {\n\n        slack_botkit.log('** Serving login URL: http://' +\n            slack_botkit.config.hostname + ':' + slack_botkit.config.port + '/login');\n\n        if (!slack_botkit.config.clientId) {\n            throw new Error(\n                'Cannot create oauth endpoints without calling configureSlackApp() with a clientId first');\n        }\n        if (!slack_botkit.config.clientSecret) {\n            throw new Error(\n                'Cannot create oauth endpoints without calling configureSlackApp() with a clientSecret first');\n        }\n        if (!slack_botkit.config.scopes) {\n            throw new Error(\n                'Cannot create oauth endpoints without calling configureSlackApp() with a list of scopes first');\n        }\n\n        var call_api = function(command, options, cb) {\n\n            var api_root = slack_botkit.config.api_root ? slack_botkit.config.api_root : 'https://slack.com';\n\n\n            slack_botkit.log('** API CALL: ' + api_root + '/api/' + command);\n            request.post(api_root + '/api/' + command, function(error, response, body) {\n                slack_botkit.debug('Got response', error, body);\n                if (!error && response.statusCode == 200) {\n                    var json = JSON.parse(body);\n                    if (json.ok) {\n                        if (cb) cb(null, json);\n                    } else {\n                        if (cb) cb(json.error, json);\n                    }\n                } else {\n                    if (cb) cb(error);\n                }\n            }).form(options);\n        };\n\n        var oauth_access = function(options, cb) {\n            call_api('oauth.access', options, cb);\n        };\n\n        var auth_test = function(options, cb) {\n            call_api('auth.test', options, cb);\n        };\n\n        webserver.get('/login', function(req, res) {\n            res.redirect(slack_botkit.getAuthorizeURL());\n        });\n\n        slack_botkit.log('** Serving oauth return endpoint: http://' +\n            slack_botkit.config.hostname + ':' + slack_botkit.config.port + '/oauth');\n\n        webserver.get('/oauth', function(req, res) {\n\n            var code = req.query.code;\n            var state = req.query.state;\n\n            var opts = {\n                client_id: slack_botkit.config.clientId,\n                client_secret: slack_botkit.config.clientSecret,\n                code: code\n            };\n\n            var redirect_params = {};\n            if (slack_botkit.config.redirectUri) {\n                Object.assign(redirect_params, req.query);\n                delete redirect_params.code;\n                delete redirect_params.state;\n\n                var redirect_query = querystring.stringify(redirect_params);\n                var redirect_uri = slack_botkit.config.redirectUri;\n                if (redirect_query) {\n                    redirect_uri = redirect_uri + '?' + redirect_query;\n                }\n                opts.redirect_uri = redirect_uri;\n            }\n\n            oauth_access(opts, function(err, auth) {\n\n                if (err) {\n                    if (callback) {\n                        callback(err, req, res);\n                    } else {\n                        res.status(500).send(err);\n                    }\n                    slack_botkit.trigger('oauth_error', [err]);\n                } else {\n\n                    // auth contains at least:\n                    // { access_token, scope, team_name}\n                    // May also contain:\n                    // { team_id } (not in incoming_webhook scope)\n                    // info about incoming webhooks:\n                    // { incoming_webhook: { url, channel, configuration_url} }\n                    // might also include slash commands:\n                    // { commands: ??}\n\n                    // what scopes did we get approved for?\n                    var scopes = auth.scope.split(/\\,/);\n\n                    // temporarily use the token we got from the oauth\n                    // we need to call auth.test to make sure the token is valid\n                    // but also so that we reliably have the team_id field!\n                    //slack_botkit.config.token = auth.access_token;\n                    auth_test({token: auth.access_token}, function(err, identity) {\n\n                        if (err) {\n                            if (callback) {\n                                callback(err, req, res);\n                            } else {\n                                res.status(500).send(err);\n                            }\n\n                            slack_botkit.trigger('oauth_error', [err]);\n\n                        } else {\n                            req.identity = identity;\n\n                            // we need to deal with any team-level provisioning info\n                            // like incoming webhooks and bot users\n                            // and also with the personal access token from the user\n\n                            slack_botkit.findTeamById(identity.team_id, function(err, team) {\n\n                                var isnew = false;\n                                if (!team) {\n                                    isnew = true;\n                                    team = {\n                                        id: identity.team_id,\n                                        createdBy: identity.user_id,\n                                        url: identity.url,\n                                        name: identity.team,\n                                    };\n                                }\n\n                                team.state = state;\n\n                                var bot = slack_botkit.spawn(team);\n\n                                if (auth.incoming_webhook) {\n                                    auth.incoming_webhook.token = auth.access_token;\n                                    auth.incoming_webhook.createdBy = identity.user_id;\n                                    team.incoming_webhook = auth.incoming_webhook;\n                                    bot.configureIncomingWebhook(team.incoming_webhook);\n                                    slack_botkit.trigger('create_incoming_webhook', [bot, team.incoming_webhook]);\n                                }\n\n                                if (auth.bot) {\n\n                                    team.bot = {\n                                        token: auth.bot.bot_access_token,\n                                        user_id: auth.bot.bot_user_id,\n                                        createdBy: identity.user_id,\n                                        app_token: auth.access_token,\n                                    };\n                                    bot.configureRTM(team.bot);\n                                    slack_botkit.trigger('create_bot', [bot, team.bot]);\n                                }\n\n                                slack_botkit.saveTeam(team, function(err, id) {\n                                    if (err) {\n                                        slack_botkit.log.error('An error occurred while saving a team: ', err);\n                                        if (callback) {\n                                            callback(err, req, res);\n                                        } else {\n                                            res.status(500).send(err);\n                                        }\n                                        slack_botkit.trigger('error', [err]);\n                                    } else {\n                                        if (isnew) {\n                                            slack_botkit.trigger('create_team', [bot, team]);\n                                        } else {\n                                            slack_botkit.trigger('update_team', [bot, team]);\n                                        }\n\n                                        if (team.bot) {\n                                            // call auth test on the bot token\n                                            // to capture its name\n                                            auth_test({\n                                                token: team.bot.token\n                                            }, function(err, auth_data) {\n                                                team.bot.name = auth_data.user;\n                                                slack_botkit.saveTeam(team, function(err, id) {\n                                                    if (err) {\n                                                        slack_botkit.log.error('An error occurred while saving a team: ', err);\n                                                    }\n                                                });\n\n                                            });\n                                        }\n\n                                        slack_botkit.storage.users.get(identity.user_id, function(err, user) {\n                                            isnew = false;\n                                            if (!user) {\n                                                isnew = true;\n                                                user = {\n                                                    id: identity.user_id,\n                                                    team_id: identity.team_id,\n                                                    user: identity.user,\n                                                };\n                                            }\n\n                                            // Always update these because the token could become invalid\n                                            // and scopes could change.\n                                            user.access_token = auth.access_token;\n                                            user.scopes = scopes;\n\n                                            slack_botkit.storage.users.save(user, function(err, id) {\n\n                                                if (err) {\n                                                    slack_botkit.log.error(\n                                                        'An error occurred while saving a user: ', err);\n                                                    if (callback) {\n                                                        callback(err, req, res);\n                                                    } else {\n                                                        res.status(500).send(err);\n                                                    }\n                                                    slack_botkit.trigger('error', [err]);\n                                                } else {\n                                                    if (isnew) {\n                                                        slack_botkit.trigger(\n                                                            'create_user',\n                                                            [bot, user, redirect_params]\n                                                        );\n                                                    } else {\n                                                        slack_botkit.trigger(\n                                                            'update_user',\n                                                            [bot, user, redirect_params]\n                                                        );\n                                                    }\n                                                    if (callback) {\n                                                        callback(null, req, res);\n                                                    } else {\n                                                        res.redirect('/');\n                                                    }\n                                                }\n                                            });\n                                        });\n                                    }\n                                });\n                            });\n                        }\n                    });\n                }\n            });\n        });\n\n        return slack_botkit;\n\n    };\n\n    slack_botkit.handleSlackEvents = function() {\n\n        slack_botkit.log('** Setting up custom handlers for processing Slack messages');\n        slack_botkit.on('message_received', function(bot, message) {\n            var mentionSyntax = '<@' + bot.identity.id + '(\\\\|' + bot.identity.name.replace('.', '\\\\.') + ')?>';\n            var mention = new RegExp(mentionSyntax, 'i');\n            var direct_mention = new RegExp('^' + mentionSyntax, 'i');\n\n            if (message.ok != undefined) {\n                // this is a confirmation of something we sent.\n                if (slack_botkit.config.require_delivery) {\n                    // loop through all active conversations this bot is having\n                    // and mark messages in conversations as delivered = true\n                    for (var t = 0; t < slack_botkit.tasks.length; t++) {\n                        if (slack_botkit.tasks[t].isActive()) {\n                            for (var c = 0; c < slack_botkit.tasks[t].convos.length; c++) {\n                                for (var s = 0; s < slack_botkit.tasks[t].convos[c].sent.length; s++) {\n                                    if (slack_botkit.tasks[t].convos[c].sent[s].api_response && slack_botkit.tasks[t].convos[c].sent[s].api_response.id == message.reply_to) {\n                                        slack_botkit.tasks[t].convos[c].sent[s].delivered = true;\n                                        slack_botkit.tasks[t].convos[c].sent[s].api_response.ts = message.ts;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return false;\n            }\n\n            slack_botkit.debug('DEFAULT SLACK MSG RECEIVED RESPONDER');\n            if ('message' == message.type) {\n\n                if (message.text) {\n                    message.text = message.text.trim();\n                }\n\n                // set up a couple of special cases based on subtype\n                if (message.subtype && message.subtype == 'channel_join') {\n                    // someone joined. maybe do something?\n                    if (message.user == bot.identity.id) {\n                        slack_botkit.trigger('bot_channel_join', [bot, message]);\n                        return false;\n                    } else {\n                        slack_botkit.trigger('user_channel_join', [bot, message]);\n                        return false;\n                    }\n                } else if (message.subtype && message.subtype == 'group_join') {\n                    // someone joined. maybe do something?\n                    if (message.user == bot.identity.id) {\n                        slack_botkit.trigger('bot_group_join', [bot, message]);\n                        return false;\n                    } else {\n                        slack_botkit.trigger('user_group_join', [bot, message]);\n                        return false;\n                    }\n                } else if (message.subtype) {\n                    slack_botkit.trigger(message.subtype, [bot, message]);\n                    return false;\n                } else if (message.channel.match(/^D/)) {\n                    // this is a direct message\n                    if (message.user == bot.identity.id && message.bot_id) {\n                        return false;\n                    }\n                    if (!message.text) {\n                        // message without text is probably an edit\n                        return false;\n                    }\n\n                    // remove direct mention so the handler doesn't have to deal with it\n                    message.text = message.text.replace(direct_mention, '')\n                    .replace(/^\\s+/, '').replace(/^\\:\\s+/, '').replace(/^\\s+/, '');\n\n                    message.event = 'direct_message';\n\n                    slack_botkit.trigger('direct_message', [bot, message]);\n                    return false;\n\n                } else {\n                    if (message.user == bot.identity.id && message.bot_id) {\n                        return false;\n                    }\n                    if (!message.text) {\n                        // message without text is probably an edit\n                        return false;\n                    }\n\n\n                    if (message.text.match(direct_mention)) {\n                        // this is a direct mention\n                        message.text = message.text.replace(direct_mention, '')\n                        .replace(/^\\s+/, '').replace(/^\\:\\s+/, '').replace(/^\\s+/, '');\n                        message.event = 'direct_mention';\n\n                        slack_botkit.trigger('direct_mention', [bot, message]);\n                        return false;\n                    } else if (message.text.match(mention)) {\n                        message.event = 'mention';\n                        slack_botkit.trigger('mention', [bot, message]);\n                        return false;\n                    } else {\n                        message.event = 'ambient';\n                        slack_botkit.trigger('ambient', [bot, message]);\n                        return false;\n\n                    }\n                }\n            } else {\n                // this is a non-message object, so trigger a custom event based on the type\n                slack_botkit.trigger(message.type, [bot, message]);\n            }\n        });\n    };\n\n    // set up the RTM message handlers once\n    slack_botkit.handleSlackEvents();\n\n    return slack_botkit;\n};\n\nmodule.exports = Slackbot;\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/Facebook.js":"var Botkit = require(__dirname + '/CoreBot.js');\nvar request = require('request');\nvar express = require('express');\nvar bodyParser = require('body-parser');\nvar crypto = require('crypto');\n\nfunction Facebookbot(configuration) {\n\n    var api_host = configuration.api_host || 'graph.facebook.com';\n\n    // Create a core botkit bot\n    var facebook_botkit = Botkit(configuration || {});\n\n    if (facebook_botkit.config.require_delivery) {\n\n        facebook_botkit.on('message_delivered', function(bot, message) {\n\n            // get list of mids in this message\n            for (var m = 0; m < message.delivery.mids.length; m++) {\n                var mid = message.delivery.mids[m];\n\n                // loop through all active conversations this bot is having\n                // and mark messages in conversations as delivered = true\n                bot.findConversation(message, function(convo) {\n                    if (convo) {\n                        for (var s = 0; s < convo.sent.length; s++) {\n                            if (convo.sent[s].sent_timestamp <= message.delivery.watermark ||\n                                (convo.sent[s].api_response && convo.sent[s].api_response.mid == mid)) {\n                                convo.sent[s].delivered = true;\n                            }\n                        }\n                    }\n                });\n            }\n\n        });\n\n    }\n\n    // customize the bot definition, which will be used when new connections\n    // spawn!\n    facebook_botkit.defineBot(function(botkit, config) {\n\n        var bot = {\n            type: 'fb',\n            botkit: botkit,\n            config: config || {},\n            utterances: botkit.utterances,\n        };\n\n        bot.startConversation = function(message, cb) {\n            botkit.startConversation(this, message, cb);\n        };\n\n        bot.createConversation = function(message, cb) {\n            botkit.createConversation(this, message, cb);\n        };\n\n\n        bot.send = function(message, cb) {\n\n            var facebook_message = {\n                recipient: {},\n                message: message.sender_action ? undefined : {}\n            };\n\n            if (typeof(message.channel) == 'string' && message.channel.match(/\\+\\d+\\(\\d\\d\\d\\)\\d\\d\\d\\-\\d\\d\\d\\d/)) {\n                facebook_message.recipient.phone_number = message.channel;\n            } else {\n                facebook_message.recipient.id = message.channel;\n            }\n\n            if (!message.sender_action) {\n                if (message.text) {\n                    facebook_message.message.text = message.text;\n                }\n\n                if (message.attachment) {\n                    facebook_message.message.attachment = message.attachment;\n                }\n\n                if (message.sticker_id) {\n                    facebook_message.message.sticker_id = message.sticker_id;\n                }\n\n                if (message.quick_replies) {\n\n                    // sanitize the length of the title to maximum of 20 chars\n                    var titleLimit = function(title) {\n                        if (title.length > 20) {\n                            var newTitle = title.substring(0, 16) + '...';\n                            return newTitle;\n                        } else {\n                            return title;\n                        }\n                    };\n\n                    facebook_message.message.quick_replies = message.quick_replies.map(function(item) {\n                        var quick_reply = {};\n                        if (item.content_type === 'text' || !item.content_type) {\n                            quick_reply = {\n                                content_type: 'text',\n                                title: titleLimit(item.title),\n                                payload: item.payload,\n                                image_url: item.image_url,\n                            };\n                        } else if (item.content_type === 'location') {\n                            quick_reply = {\n                                content_type: 'location'\n                            };\n                        } else {\n                            // Future quick replies types\n                        }\n                        return quick_reply;\n                    });\n                }\n            } else {\n                facebook_message.sender_action = message.sender_action;\n            }\n\n            if (message.sender_action) {\n                facebook_message.sender_action = message.sender_action;\n            }\n\n            if (message.notification_type) {\n                facebook_message.notification_type = message.notification_type;\n            }\n\n            //Add Access Token to outgoing request\n            facebook_message.access_token = configuration.access_token;\n\n            request({\n                method: 'POST',\n                json: true,\n                headers: {\n                    'content-type': 'application/json',\n                },\n                body: facebook_message,\n                uri: 'https://' + api_host + '/v2.6/me/messages'\n            },\n                function(err, res, body) {\n\n\n                    if (err) {\n                        botkit.debug('WEBHOOK ERROR', err);\n                        return cb && cb(err);\n                    }\n\n                    if (body.error) {\n                        botkit.debug('API ERROR', body.error);\n                        return cb && cb(body.error.message);\n                    }\n\n                    botkit.debug('WEBHOOK SUCCESS', body);\n                    cb && cb(null, body);\n                });\n        };\n\n        bot.startTyping = function(src, cb) {\n            var msg = {};\n            msg.channel = src.channel;\n            msg.sender_action = 'typing_on';\n            bot.say(msg, cb);\n        };\n\n        bot.stopTyping = function(src, cb) {\n            var msg = {};\n            msg.channel = src.channel;\n            msg.sender_action = 'typing_off';\n            bot.say(msg, cb);\n        };\n\n        bot.replyWithTyping = function(src, resp, cb) {\n            var textLength;\n\n            if (typeof(resp) == 'string') {\n                textLength = resp.length;\n            } else if (resp.text) {\n                textLength = resp.text.length;\n            } else {\n                textLength = 80; //default attachement text length\n            }\n\n            var avgWPM = 85;\n            var avgCPM = avgWPM * 7;\n\n            var typingLength = Math.min(Math.floor(textLength / (avgCPM / 60)) * 1000, 5000);\n\n            bot.startTyping(src, function(err) {\n                if (err) console.log(err);\n                setTimeout(function() {\n                    bot.reply(src, resp, cb);\n                }, typingLength);\n            });\n\n        };\n\n\n        bot.reply = function(src, resp, cb) {\n            var msg = {};\n\n            if (typeof(resp) == 'string') {\n                msg.text = resp;\n            } else {\n                msg = resp;\n            }\n\n            msg.channel = src.channel;\n\n            bot.say(msg, cb);\n        };\n\n        bot.findConversation = function(message, cb) {\n            botkit.debug('CUSTOM FIND CONVO', message.user, message.channel);\n            for (var t = 0; t < botkit.tasks.length; t++) {\n                for (var c = 0; c < botkit.tasks[t].convos.length; c++) {\n                    if (\n                        botkit.tasks[t].convos[c].isActive() &&\n                        botkit.tasks[t].convos[c].source_message.user == message.user\n                    ) {\n                        botkit.debug('FOUND EXISTING CONVO!');\n                        cb(botkit.tasks[t].convos[c]);\n                        return;\n                    }\n                }\n            }\n\n            cb();\n        };\n        return bot;\n    });\n\n    // set up a web route for receiving outgoing webhooks and/or slash commands\n    facebook_botkit.createWebhookEndpoints = function(webserver, bot, cb) {\n\n        facebook_botkit.log(\n            '** Serving webhook endpoints for Messenger Platform at: ' +\n            'http://' + facebook_botkit.config.hostname + ':' + facebook_botkit.config.port + '/facebook/receive');\n        webserver.post('/facebook/receive', function(req, res) {\n            res.send('ok');\n            facebook_botkit.handleWebhookPayload(req, res, bot);\n        });\n\n        webserver.get('/facebook/receive', function(req, res) {\n            if (req.query['hub.mode'] == 'subscribe') {\n                if (req.query['hub.verify_token'] == configuration.verify_token) {\n                    res.send(req.query['hub.challenge']);\n                } else {\n                    res.send('OK');\n                }\n            }\n        });\n\n        if (cb) {\n            cb();\n        }\n\n        return facebook_botkit;\n    };\n\n    facebook_botkit.handleWebhookPayload = function(req, res, bot) {\n\n        var obj = req.body;\n        if (obj.entry) {\n            for (var e = 0; e < obj.entry.length; e++) {\n                for (var m = 0; m < obj.entry[e].messaging.length; m++) {\n                    var facebook_message = obj.entry[e].messaging[m];\n                    if (facebook_message.message) {\n                        var message = {\n                            text: facebook_message.message.text,\n                            user: facebook_message.sender.id,\n                            channel: facebook_message.sender.id,\n                            page: facebook_message.recipient.id,\n                            timestamp: facebook_message.timestamp,\n                            seq: facebook_message.message.seq,\n                            is_echo: facebook_message.message.is_echo,\n                            mid: facebook_message.message.mid,\n                            sticker_id: facebook_message.message.sticker_id,\n                            attachments: facebook_message.message.attachments,\n                            quick_reply: facebook_message.message.quick_reply,\n                            type: 'user_message',\n                        };\n\n                        facebook_botkit.receiveMessage(bot, message);\n                    } else if (facebook_message.postback) {\n\n                        // trigger BOTH a facebook_postback event\n                        // and a normal message received event.\n                        // this allows developers to receive postbacks as part of a conversation.\n                        var message = {\n                            text: facebook_message.postback.payload,\n                            payload: facebook_message.postback.payload,\n                            user: facebook_message.sender.id,\n                            channel: facebook_message.sender.id,\n                            page: facebook_message.recipient.id,\n                            timestamp: facebook_message.timestamp,\n                            referral: facebook_message.postback.referral,\n                        };\n\n                        facebook_botkit.trigger('facebook_postback', [bot, message]);\n\n                        if (facebook_botkit.config.receive_via_postback) {\n                            var message = {\n                                text: facebook_message.postback.payload,\n                                user: facebook_message.sender.id,\n                                channel: facebook_message.sender.id,\n                                page: facebook_message.recipient.id,\n                                timestamp: facebook_message.timestamp,\n                                type: 'facebook_postback',\n                                referral: facebook_message.postback.referral,\n                            };\n\n                            facebook_botkit.receiveMessage(bot, message);\n                        }\n\n                    } else if (facebook_message.optin) {\n\n                        var message = {\n                            optin: facebook_message.optin,\n                            user: facebook_message.sender.id,\n                            channel: facebook_message.sender.id,\n                            page: facebook_message.recipient.id,\n                            timestamp: facebook_message.timestamp,\n                        };\n\n                        facebook_botkit.trigger('facebook_optin', [bot, message]);\n                    } else if (facebook_message.delivery) {\n\n                        var message = {\n                            delivery: facebook_message.delivery,\n                            user: facebook_message.sender.id,\n                            channel: facebook_message.sender.id,\n                            page: facebook_message.recipient.id\n                        };\n\n                        facebook_botkit.trigger('message_delivered', [bot, message]);\n                    } else if (facebook_message.read) {\n\n                        var message = {\n                            read: facebook_message.read,\n                            user: facebook_message.sender.id,\n                            channel: facebook_message.sender.id,\n                            page: facebook_message.recipient.id,\n                            timestamp: facebook_message.timestamp,\n                        };\n\n                        facebook_botkit.trigger('message_read', [bot, message]);\n                    } else if (facebook_message.referral) {\n                        var message = {\n                            user: facebook_message.sender.id,\n                            channel: facebook_message.sender.id,\n                            page: facebook_message.recipient.id,\n                            timestamp: facebook_message.timestamp,\n                            referral: facebook_message.referral,\n                        };\n\n                        facebook_botkit.trigger('facebook_referral', [bot, message]);\n                    } else if (facebook_message.account_linking) {\n                        var message = {\n                            user: facebook_message.sender.id,\n                            channel: facebook_message.sender.id,\n                            timestamp: facebook_message.timestamp,\n                            account_linking: facebook_message.account_linking,\n                        };\n\n                        facebook_botkit.trigger('facebook_account_linking', [bot, message]);\n                    }  else {\n                        facebook_botkit.log('Got an unexpected message from Facebook: ', facebook_message);\n                    }\n                }\n            }\n        }\n    };\n\n    facebook_botkit.setupWebserver = function(port, cb) {\n\n        if (!port) {\n            throw new Error('Cannot start webserver without a port');\n        }\n\n        var static_dir =  process.cwd() + '/public';\n\n        if (facebook_botkit.config && facebook_botkit.config.webserver && facebook_botkit.config.webserver.static_dir)\n            static_dir = facebook_botkit.config.webserver.static_dir;\n\n        facebook_botkit.config.port = port;\n\n        facebook_botkit.webserver = express();\n\n        // Validate that requests come from facebook, and abort on validation errors\n        if (facebook_botkit.config.validate_requests === true) {\n            // Load verify middleware just for post route on our receive webhook, and catch any errors it might throw to prevent the request from being parsed further.\n            facebook_botkit.webserver.post('/facebook/receive', bodyParser.json({verify: verifyRequest}));\n            facebook_botkit.webserver.use(abortOnValidationError);\n        }\n\n        facebook_botkit.webserver.use(bodyParser.json());\n        facebook_botkit.webserver.use(bodyParser.urlencoded({ extended: true }));\n        facebook_botkit.webserver.use(express.static(static_dir));\n\n        var server = facebook_botkit.webserver.listen(\n            facebook_botkit.config.port,\n            facebook_botkit.config.hostname,\n            function() {\n                facebook_botkit.log('** Starting webserver on port ' +\n                    facebook_botkit.config.port);\n                if (cb) { cb(null, facebook_botkit.webserver); }\n            });\n\n\n        request.post('https://' + api_host + '/me/subscribed_apps?access_token=' + configuration.access_token,\n            function(err, res, body) {\n                if (err) {\n                    facebook_botkit.log('Could not subscribe to page messages');\n                } else {\n                    facebook_botkit.debug('Successfully subscribed to Facebook events:', body);\n                    facebook_botkit.startTicking();\n                }\n            });\n\n        return facebook_botkit;\n\n    };\n\n    var messenger_profile_api = {\n        greeting: function(payload) {\n            var message = {\n                'greeting': []\n            };\n            if (Array.isArray(payload)) {\n                message.greeting = payload;\n            } else {\n                message.greeting.push({\n                    'locale': 'default',\n                    'text': payload\n                });\n            }\n            facebook_botkit.api.messenger_profile.postAPI(message);\n        },\n        delete_greeting: function() {\n            facebook_botkit.api.messenger_profile.deleteAPI('greeting');\n        },\n        get_greeting: function(cb) {\n            facebook_botkit.api.messenger_profile.getAPI('greeting', cb);\n        },\n        get_started: function(payload) {\n            var message = {\n                'get_started': {\n                    'payload': payload\n                }\n            };\n            facebook_botkit.api.messenger_profile.postAPI(message);\n        },\n        delete_get_started: function() {\n            facebook_botkit.api.messenger_profile.deleteAPI('get_started');\n        },\n        get_get_started: function(cb) {\n            facebook_botkit.api.messenger_profile.getAPI('get_started', cb);\n        },\n        menu: function(payload) {\n            var messege = {\n                persistent_menu: payload\n            };\n            facebook_botkit.api.messenger_profile.postAPI(messege);\n        },\n        delete_menu: function() {\n            facebook_botkit.api.messenger_profile.deleteAPI('persistent_menu');\n        },\n        get_menu: function(cb) {\n            facebook_botkit.api.messenger_profile.getAPI('persistent_menu', cb);\n        },\n        account_linking: function(payload) {\n            var message = {\n                'account_linking_url': payload\n            };\n            facebook_botkit.api.messenger_profile.postAPI(message);\n        },\n        delete_account_linking: function() {\n            facebook_botkit.api.messenger_profile.deleteAPI('account_linking_url');\n        },\n        get_account_linking: function(cb) {\n            facebook_botkit.api.messenger_profile.getAPI('account_linking_url', cb);\n        },\n        domain_whitelist: function(payload) {\n            var message = {\n                'whitelisted_domains': Array.isArray(payload) ? payload : [payload]\n            };\n            facebook_botkit.api.messenger_profile.postAPI(message);\n        },\n        delete_domain_whitelist: function() {\n            facebook_botkit.api.messenger_profile.deleteAPI('whitelisted_domains');\n        },\n        get_domain_whitelist: function(cb) {\n            facebook_botkit.api.messenger_profile.getAPI('whitelisted_domains', cb);\n        },\n        postAPI: function(message) {\n            request.post('https://graph.facebook.com/v2.6/me/messenger_profile?access_token=' + configuration.access_token,\n                {form: message},\n                function(err, res, body) {\n                    if (err) {\n                        facebook_botkit.log('Could not configure messenger profile');\n                    } else {\n\n                        var results = null;\n                        try {\n                            results = JSON.parse(body);\n                        } catch (err) {\n                            facebook_botkit.log('ERROR in messenger profile API call: Could not parse JSON', err, body);\n                        }\n\n                        if (results) {\n                            if (results.error) {\n                                facebook_botkit.log('ERROR in messenger profile API call: ', results.error.message);\n                            } else {\n                                facebook_botkit.debug('Successfully configured messenger profile', body);\n                            }\n                        }\n                    }\n                });\n        },\n        deleteAPI: function(type) {\n            var message = {\n                'fields': [type]\n            };\n            request.delete('https://graph.facebook.com/v2.6/me/messenger_profile?access_token=' + configuration.access_token,\n                {form: message},\n                function(err, res, body) {\n                    if (err) {\n                        facebook_botkit.log('Could not configure messenger profile');\n                    } else {\n                        facebook_botkit.debug('Successfully configured messenger profile', message);\n                    }\n                });\n        },\n        getAPI: function(fields, cb) {\n            request.get('https://graph.facebook.com/v2.6/me/messenger_profile?fields=' + fields + '&access_token=' + configuration.access_token,\n                function(err, res, body) {\n                    if (err) {\n                        facebook_botkit.log('Could not get messenger profile');\n                        cb(err);\n                    } else {\n                        facebook_botkit.debug('Successfully got messenger profile ', body);\n                        cb(null, body);\n                    }\n                });\n        },\n        get_messenger_code: function(image_size, cb) {\n            var message = {\n                'type': 'standard',\n                'image_size': image_size || 1000\n            };\n            request.post('https://graph.facebook.com/v2.6/me/messenger_codes?access_token=' + configuration.access_token,\n                {form: message},\n                function(err, res, body) {\n                    if (err) {\n                        facebook_botkit.log('Could not configure get messenger code');\n                        cb(err);\n                    } else {\n\n                        var results = null;\n                        try {\n                            results = JSON.parse(body);\n                        } catch (err) {\n                            facebook_botkit.log('ERROR in messenger code API call: Could not parse JSON', err, body);\n                            cb(err);\n                        }\n\n                        if (results) {\n                            if (results.error) {\n                                facebook_botkit.log('ERROR in messenger code API call: ', results.error.message);\n                                cb(results.error);\n                            } else {\n                                var uri = results.uri;\n                                facebook_botkit.log('Successfully got messenger code', uri);\n                                cb(null, uri);\n                            }\n                        }\n                    }\n                });\n        },\n        deleteAPI: function(message) {\n                request.delete('https://' + api_host + '/v2.6/me/thread_settings?access_token=' + configuration.access_token,\n                    {form: message},\n                    function(err, res, body) {\n                        if (err) {\n                            facebook_botkit.log('Could not configure thread settings');\n                        } else {\n                            facebook_botkit.debug('Successfully configured thread settings', message);\n                        }\n                    });\n            }\n    };\n\n    facebook_botkit.api = {\n        'messenger_profile': messenger_profile_api,\n        'thread_settings': messenger_profile_api\n    };\n\n    // Verifies the SHA1 signature of the raw request payload before bodyParser parses it\n    // Will abort parsing if signature is invalid, and pass a generic error to response\n    function verifyRequest(req, res, buf, encoding) {\n        var expected = req.headers['x-hub-signature'];\n        var calculated = getSignature(buf);\n        if (expected !== calculated) {\n            throw new Error('Invalid signature on incoming request');\n        } else {\n            // facebook_botkit.debug('** X-Hub Verification successful!')\n        }\n    }\n\n    function getSignature(buf) {\n        var hmac = crypto.createHmac('sha1', facebook_botkit.config.app_secret);\n        hmac.update(buf, 'utf-8');\n        return 'sha1=' + hmac.digest('hex');\n    }\n\n    function abortOnValidationError(err, req, res, next) {\n        if (err) {\n            facebook_botkit.log('** Invalid X-HUB signature on incoming request!');\n            facebook_botkit.debug('** X-HUB Validation Error:', err);\n            res.status(400).send({\n                error: 'Invalid signature.'\n            });\n        } else {\n            next();\n        }\n    }\n\n    return facebook_botkit;\n};\n\nmodule.exports = Facebookbot;\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/TwilioIPMBot.js":"var Botkit = require(__dirname + '/CoreBot.js');\nvar request = require('request');\nvar express = require('express');\nvar bodyParser = require('body-parser');\nvar twilio = require('twilio');\nvar async = require('async');\n\nvar AccessToken = twilio.AccessToken;\nvar IpMessagingGrant = AccessToken.IpMessagingGrant;\n\nfunction Twiliobot(configuration) {\n\n    // Create a core botkit bot\n    var twilio_botkit = Botkit(configuration || {});\n\n    // customize the bot definition, which will be used when new connections\n    // spawn!\n    twilio_botkit.defineBot(function(botkit, config) {\n        var bot = {\n            type: 'twilioipm',\n            botkit: botkit,\n            config: config || {},\n            utterances: botkit.utterances,\n        };\n\n        bot.startConversation = function(message, cb) {\n            botkit.startConversation(this, message, cb);\n        };\n\n        bot.send = function(message, cb) {\n            botkit.debug('SEND ', message);\n\n            if (bot.identity === null || bot.identity === '') {\n                bot.api.channels(message.channel).messages.create({\n                    body: message.text,\n                }).then(function(response) {\n                    cb(null, response);\n                }).catch(function(err) {\n                    cb(err);\n                });\n            } else {\n                bot.api.channels(message.channel).messages.create({\n                    body: message.text,\n                    from: bot.identity\n                }).then(function(response) {\n                    cb(null, response);\n                }).catch(function(err) {\n                    cb(err);\n                });\n            }\n        };\n\n        bot.reply = function(src, resp, cb) {\n            var msg = {};\n\n            if (typeof(resp) == 'string') {\n                msg.text = resp;\n            } else {\n                msg = resp;\n            }\n\n            msg.user = src.user;\n            msg.channel = src.channel;\n\n            bot.say(msg, cb);\n        };\n\n        bot.autoJoinChannels = function() {\n          bot.api.channels.list().then(function(full_channel_list) {\n            if (bot.config.autojoin === true) {\n                bot.channels = full_channel_list;\n                bot.channels.channels.forEach(function(chan) {\n                    bot.api.channels(chan.sid).members.create({\n                        identity: bot.identity\n                    }).then(function(response) {\n                        botkit.debug('added ' +\n                          bot.identity + ' as a member of the ' + chan.friendly_name);\n                    }).fail(function(error) {\n                        botkit.debug('Couldn\\'t join the channel: ' +\n                            chan.friendly_name + ': ' + error);\n                    });\n                });\n            } else if (bot.identity) {\n\n                // load up a list of all the channels that the bot is currently\n\n                bot.channels = {\n                    channels: []\n                };\n\n                async.each(full_channel_list.channels, function(chan, next) {\n                    bot.api.channels(chan.sid).members.list().then(function(members) {\n                        for (var x = 0; x < members.members.length; x++) {\n                            if (members.members[x].identity == bot.identity) {\n                                bot.channels.channels.push(chan);\n                            }\n                        }\n                        next();\n                    }).fail(function(error) {\n                        botkit.log('Error loading channel member list: ', error);\n                        next();\n                    });\n                });\n            }\n        }).fail(function(error) {\n            botkit.log('Error loading channel list: ' + error);\n            // fails if no channels exist\n            // set the channels to empty\n            bot.channels = { channels: [] };\n        });\n\n      };\n\n        bot.configureBotIdentity = function() {\n            if (bot.identity !== null || bot.identity !== '') {\n                var userRespIter = 0;\n                var existingIdentity = null;\n\n                // try the get by identity thing\n                bot.api.users(bot.identity).get().then(function(response) {\n                    bot.autoJoinChannels();\n                }).fail(function(error) {\n                    // if not make the new user and see if they need to be added to all the channels\n                    bot.api.users.create({\n                        identity: bot.identity\n                    }).then(function(response) {\n                        bot.autoJoinChannels();\n                    }).fail(function(error) {\n                        botkit.log('Could not get Bot Identity:');\n                        botkit.log(error);\n                        process.exit(1);\n                    });\n                });\n            }\n        };\n\n        /**\n        * This handles the particulars of finding an existing conversation or\n        * topic to fit the message into...\n        */\n        bot.findConversation = function(message, cb) {\n            botkit.debug('CUSTOM FIND CONVO', message.user, message.channel);\n            for (var t = 0; t < botkit.tasks.length; t++) {\n                for (var c = 0; c < botkit.tasks[t].convos.length; c++) {\n                    if (\n                        botkit.tasks[t].convos[c].isActive() &&\n                        botkit.tasks[t].convos[c].source_message.user == message.user &&\n                            botkit.tasks[t].convos[c].source_message.channel == message.channel\n                    ) {\n                        botkit.debug('FOUND EXISTING CONVO!');\n                        cb(botkit.tasks[t].convos[c]);\n                        return;\n                    }\n                }\n            }\n\n            cb();\n        };\n\n\n        bot.client = new twilio.IpMessagingClient(config.TWILIO_ACCOUNT_SID, config.TWILIO_AUTH_TOKEN);\n        bot.api = bot.client.services(config.TWILIO_IPM_SERVICE_SID);\n\n        if (config.identity) {\n            bot.identity = config.identity;\n            bot.configureBotIdentity();\n        }\n\n        return bot;\n\n    });\n\n\n    twilio_botkit.setupWebserver = function(port, cb) {\n\n        if (!port) {\n            throw new Error('Cannot start webserver without a port');\n        }\n        if (isNaN(port)) {\n            throw new Error('Specified port is not a valid number');\n        }\n\n        twilio_botkit.config.port = port;\n\n        twilio_botkit.webserver = express();\n        twilio_botkit.webserver.use(bodyParser.json());\n        twilio_botkit.webserver.use(bodyParser.urlencoded({ extended: true }));\n        twilio_botkit.webserver.use(express.static(__dirname + '/public'));\n\n        var server = twilio_botkit.webserver.listen(\n            twilio_botkit.config.port,\n            twilio_botkit.config.hostname,\n            function() {\n                twilio_botkit.log('** Starting webserver on port ' +\n                    twilio_botkit.config.port);\n                if (cb) { cb(null, twilio_botkit.webserver); }\n            });\n\n        return twilio_botkit;\n\n    };\n\n\n\n\n    // set up a web route for receiving outgoing webhooks and/or slash commands\n    twilio_botkit.createWebhookEndpoints = function(webserver, bot) {\n\n        twilio_botkit.log(\n            '** Serving webhook endpoints for receiving messages ' +\n            'webhooks at: http://' + twilio_botkit.config.hostname + ':' +\n                twilio_botkit.config.port + '/twilio/receive');\n        webserver.post('/twilio/receive', function(req, res) {\n\n            res.status(200);\n            res.send('ok');\n            twilio_botkit.handleWebhookPayload(req, res, bot);\n\n        });\n\n        twilio_botkit.startTicking();\n\n        return twilio_botkit;\n    };\n\n    twilio_botkit.handleWebhookPayload = function(req, res, bot) {\n        // ensure all messages\n        // have a user & channel\n        var message = req.body;\n        if (req.body.EventType == 'onMessageSent') {\n\n            // customize fields to be compatible with Botkit\n            message.text = req.body.Body;\n            message.from = req.body.From;\n            message.to = req.body.To;\n            message.user = req.body.From;\n            message.channel = req.body.ChannelSid;\n\n            twilio_botkit.receiveMessage(bot, message);\n\n        }else if (req.body.EventType == 'onChannelAdded' || req.body.EventType == 'onChannelAdd') {\n            // this event has a channel sid but not a user\n            message.channel = req.body.ChannelSid;\n            twilio_botkit.trigger(req.body.EventType, [bot, message]);\n\n        }else if (req.body.EventType == 'onChannelDestroyed' || req.body.EventType == 'onChannelDestroy') {\n            // this event has a channel sid but not a user\n            message.channel = req.body.ChannelSid;\n            twilio_botkit.trigger(req.body.EventType, [bot, message]);\n\n        }else if (req.body.EventType == 'onMemberAdded' || req.body.EventType == 'onMemberAdd') {\n            // should user be MemberSid the The Member Sid of the newly added Member\n            message.user = req.body.Identity;\n            message.channel = req.body.ChannelSid;\n            twilio_botkit.trigger(req.body.EventType, [bot, message]);\n        } else if (req.body.EventType == 'onMemberRemoved' || req.body.EventType == 'onMemberRemove') {\n            message.user = req.body.Identity;\n            message.channel = req.body.ChannelSid;\n            twilio_botkit.trigger(req.body.EventType, [bot, message]);\n\n            if (req.body.EventType == 'onMemberRemoved') {\n\n            }\n        } else {\n            twilio_botkit.trigger(req.body.EventType, [bot, message]);\n        }\n    };\n\n    // handle events here\n    twilio_botkit.handleTwilioEvents = function() {\n        twilio_botkit.log('** Setting up custom handlers for processing Twilio messages');\n        twilio_botkit.on('message_received', function(bot, message) {\n\n\n\n            if (bot.identity && message.from == bot.identity) {\n                return false;\n            }\n\n            if (!message.text) {\n                // message without text is probably an edit\n                return false;\n            }\n\n            if (bot.identity) {\n                var channels = bot.channels.channels;\n\n                // if its not in a channel with the bot\n                var apprChan = channels.filter(function(ch) {\n                    return ch.sid == message.channel;\n                });\n\n                if (apprChan.length === 0) {\n                    return false;\n                }\n            }\n        });\n\n\n        // if a member is removed from a channel, check to see if it matches the bot's identity\n        // and if so remove it from the list of channels the bot listens to\n        twilio_botkit.on('onMemberRemoved', function(bot, message) {\n            if (bot.identity && message.user == bot.identity) {\n                // remove that channel from bot.channels.channels\n                var chan_to_rem = bot.channels.channels.map(function(ch) {\n                return ch.sid;\n            }).indexOf(message.channel);\n\n                if (chan_to_rem != -1) {\n                    bot.channels.channels.splice(chan_to_rem, 1);\n                    twilio_botkit.debug('Unsubscribing from channel because of memberremove.');\n\n                }\n            } else if (bot.identity) {\n                var channels = bot.channels.channels;\n\n                // if its not in a channel with the bot\n                var apprChan = channels.filter(function(ch) {\n                    return ch.sid == message.channel;\n                });\n\n                if (apprChan.length === 0) {\n                    return false;\n                }\n            }\n\n            if (bot.identity && bot.identity == message.user) {\n                twilio_botkit.trigger('bot_channel_leave', [bot, message]);\n            } else {\n                twilio_botkit.trigger('user_channel_leave', [bot, message]);\n            }\n        });\n\n        twilio_botkit.on('onMemberAdded', function(bot, message) {\n            if (bot.identity && message.user == bot.identity) {\n                bot.api.channels(message.channel).get().then(function(response) {\n                    bot.channels.channels.push(response);\n                    twilio_botkit.debug('Subscribing to channel because of memberadd.');\n\n                }).fail(function(error) {\n                    botkit.log(error);\n                });\n            } else if (bot.identity) {\n                var channels = bot.channels.channels;\n\n                // if its not in a channel with the bot\n                var apprChan = channels.filter(function(ch) {\n                    return ch.sid == message.channel;\n                });\n\n                if (apprChan.length === 0) {\n                    return false;\n                }\n            }\n\n            if (bot.identity && bot.identity == message.user) {\n                twilio_botkit.trigger('bot_channel_join', [bot, message]);\n            } else {\n                twilio_botkit.trigger('user_channel_join', [bot, message]);\n            }\n\n        });\n\n\n        // if a channel is destroyed, remove it from the list of channels this bot listens to\n        twilio_botkit.on('onChannelDestroyed', function(bot, message) {\n            if (bot.identity) {\n                var chan_to_rem = bot.channels.channels.map(function(ch) {\n                return ch.sid;\n            }).indexOf(message.channel);\n                if (chan_to_rem != -1) {\n                    bot.channels.channels.splice(chan_to_rem, 1);\n                    twilio_botkit.debug('Unsubscribing from destroyed channel.');\n                }\n            }\n        });\n\n        // if a channel is created, and the bot is set in autojoin mode, join the channel\n        twilio_botkit.on('onChannelAdded', function(bot, message) {\n            if (bot.identity && bot.config.autojoin === true) {\n                // join the channel\n                bot.api.channels(message.channel).members.create({\n                    identity: bot.identity\n                }).then(function(response) {\n                    bot.api.channels(message.channel).get().then(function(response) {\n                        bot.channels.channels.push(response);\n                        twilio_botkit.debug('Subscribing to new channel.');\n\n                    }).fail(function(error) {\n                        botkit.log(error);\n                    });\n                }).fail(function(error) {\n                    botkit.log(error);\n                });\n            }\n        });\n\n    };\n\n    twilio_botkit.handleTwilioEvents();\n\n    return twilio_botkit;\n\n}\n\nmodule.exports = Twiliobot;\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/BotFramework.js":"var Botkit = require(__dirname + '/CoreBot.js');\nvar builder = require('botbuilder');\nvar express = require('express');\nvar bodyParser = require('body-parser');\n\nfunction BotFrameworkBot(configuration) {\n\n    // Create a core botkit bot\n    var bf_botkit = Botkit(configuration || {});\n\n    // customize the bot definition, which will be used when new connections\n    // spawn!\n    bf_botkit.defineBot(function(botkit, config) {\n\n        var bot = {\n            botkit: botkit,\n            config: config || {},\n            utterances: botkit.utterances,\n        };\n\n        bot.startConversation = function(message, cb) {\n            botkit.startConversation(this, message, cb);\n        };\n\n        bot.send = function(message, cb) {\n            function done(err) {\n                if (cb) {\n                    cb(err);\n                }\n            }\n\n            if (!message || !message.address) {\n                if (cb) {\n                    cb(new Error('Outgoing message requires a valid address...'));\n                }\n                return;\n            }\n\n            // Copy message minus user & channel fields\n            var bf_message = {};\n            for (var key in message) {\n                switch (key) {\n                    case 'user':\n                    case 'channel':\n                        // ignore\n                        break;\n                    default:\n                        bf_message[key] = message[key];\n                        break;\n                }\n            }\n            if (!bf_message.type) {\n                bf_message.type = 'message';\n            }\n\n            // Ensure the message address has a valid conversation id.\n            if (!bf_message.address.conversation) {\n                bot.connector.startConversation(bf_message.address, function(err, adr) {\n                    if (!err) {\n                        // Send message through connector\n                        bf_message.address = adr;\n                        bot.connector.send([bf_message], done);\n                    } else {\n                        done(err);\n                    }\n                });\n            } else {\n                // Send message through connector\n                bot.connector.send([bf_message], done);\n            }\n        };\n\n        bot.reply = function(src, resp, cb) {\n            var msg = {};\n\n            if (typeof(resp) == 'string') {\n                msg.text = resp;\n            } else {\n                msg = resp;\n            }\n\n            msg.user = src.user;\n            msg.channel = src.channel;\n            msg.address = src.address;\n\n            bot.say(msg, cb);\n        };\n\n        bot.findConversation = function(message, cb) {\n            botkit.debug('CUSTOM FIND CONVO', message.user, message.channel);\n            for (var t = 0; t < botkit.tasks.length; t++) {\n                for (var c = 0; c < botkit.tasks[t].convos.length; c++) {\n                    if (\n                        botkit.tasks[t].convos[c].isActive() &&\n                        botkit.tasks[t].convos[c].source_message.user == message.user &&\n                        botkit.tasks[t].convos[c].source_message.channel == message.channel\n                    ) {\n                        botkit.debug('FOUND EXISTING CONVO!');\n                        cb(botkit.tasks[t].convos[c]);\n                        return;\n                    }\n                }\n            }\n\n            cb();\n        };\n\n        // Create connector\n        bot.connector = new builder.ChatConnector(config);\n\n        return bot;\n\n    });\n\n\n    // set up a web route for receiving outgoing webhooks and/or slash commands\n\n    bf_botkit.createWebhookEndpoints = function(webserver, bot, cb) {\n\n        // Listen for incoming events\n        bf_botkit.log(\n            '** Serving webhook endpoints for the Microsoft Bot Framework at: ' +\n                'http://' + bf_botkit.config.hostname + ':' +\n                bf_botkit.config.port + '/botframework/receive');\n        webserver.post('/botframework/receive', bot.connector.listen());\n\n        // Receive events from chat connector\n        bot.connector.onEvent(function(events, done) {\n            for (var i = 0; i < events.length; i++) {\n                // Break out user & channel fields from event\n                // - These fields are used as keys for tracking conversations and storage.\n                // - Prefixing with channelId to ensure that users & channels for different\n                //   platforms are unique.\n                var bf_event = events[i];\n                var prefix = bf_event.address.channelId + ':';\n                bf_event.user = prefix + bf_event.address.user.id;\n                bf_event.channel = prefix + bf_event.address.conversation.id;\n\n                // Dispatch event\n                if (bf_event.type === 'message') {\n                    bf_botkit.receiveMessage(bot, bf_event);\n                } else {\n                    bf_botkit.trigger(bf_event.type, [bot, bf_event]);\n                }\n            }\n\n            if (done) {\n                done(null);\n            }\n        });\n\n        if (cb) {\n            cb();\n        }\n\n        bf_botkit.startTicking();\n\n        return bf_botkit;\n    };\n\n    bf_botkit.setupWebserver = function(port, cb) {\n\n        if (!port) {\n            throw new Error('Cannot start webserver without a port');\n        }\n        if (isNaN(port)) {\n            throw new Error('Specified port is not a valid number');\n        }\n\n        bf_botkit.config.port = port;\n\n        bf_botkit.webserver = express();\n        bf_botkit.webserver.use(bodyParser.json());\n        bf_botkit.webserver.use(bodyParser.urlencoded({ extended: true }));\n        bf_botkit.webserver.use(express.static(__dirname + '/public'));\n\n        var server = bf_botkit.webserver.listen(\n            bf_botkit.config.port,\n            bf_botkit.config.hostname,\n            function() {\n                bf_botkit.log('** Starting webserver on port ' +\n                    bf_botkit.config.port);\n                if (cb) { cb(null, bf_botkit.webserver); }\n            });\n\n        return bf_botkit;\n\n    };\n\n    return bf_botkit;\n};\n\nmodule.exports = BotFrameworkBot;\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/CiscoSparkbot.js":"var Botkit = require(__dirname + '/CoreBot.js');\nvar request = require('request');\nvar express = require('express');\nvar bodyParser = require('body-parser');\nvar url = require('url');\nvar crypto = require('crypto');\n\nfunction Sparkbot(configuration) {\n\n    // Create a core botkit bot\n    var controller = Botkit(configuration || {});\n\n    if (!controller.config.ciscospark_access_token) {\n        throw new Error('ciscospark_access_token required to create controller');\n    } else {\n        controller.api = require('ciscospark').init({\n            credentials: {\n                authorization: {\n                    access_token: controller.config.ciscospark_access_token\n                }\n            }\n        });\n\n        if (!controller.api) {\n            throw new Error('Could not create Cisco Spark API');\n        }\n\n        controller.api.people.get('me').then(function(identity) {\n            console.log('Cisco Spark: My identity is', identity);\n            controller.identity = identity;\n        }).catch(function(err) {\n            throw new Error(err);\n        });\n    }\n\n    if (!controller.config.public_address) {\n        throw new Error('public_address parameter required to receive webhooks');\n    } else {\n\n        var endpoint = url.parse(controller.config.public_address);\n        if (!endpoint.hostname) {\n            throw new Error('Could not determine hostname of public address: ' + controller.config.public_address);\n        } else if (endpoint.protocol != 'https:') {\n            throw new Error('Please specify an SSL-enabled url for your public address: ' + controller.config.public_address);\n        } else {\n            controller.config.public_address = endpoint.hostname + (endpoint.port ? ':' + endpoint.port : '');\n        }\n\n    }\n\n    if (!controller.config.secret) {\n        console.log('WARNING: No secret specified. Source of incoming webhooks will not be validated. https://developer.ciscospark.com/webhooks-explained.html#auth');\n        // throw new Error('secret parameter required to secure webhooks');\n    }\n\n\n    controller.resetWebhookSubscriptions = function() {\n        controller.api.webhooks.list().then(function(list) {\n            for (var i = 0; i < list.items.length; i++) {\n                controller.api.webhooks.remove(list.items[i]).then(function(res) {\n                    console.log('Removed subscription: ' + list.items[i].name);\n                }).catch(function(err) {\n                    console.log('Error removing subscription:', err);\n                });\n            }\n        });\n    };\n\n    // set up a web route for receiving outgoing webhooks and/or slash commands\n    controller.createWebhookEndpoints = function(webserver, bot, cb) {\n\n\n        var webhook_name = controller.config.webhook_name || 'Botkit Firehose';\n\n        controller.log(\n            '** Serving webhook endpoints for Cisco Spark Platform at: ' +\n            'http://' + controller.config.hostname + ':' + controller.config.port + '/ciscospark/receive');\n        webserver.post('/ciscospark/receive', function(req, res) {\n\n            controller.handleWebhookPayload(req, res, bot);\n\n        });\n\n\n        var list = controller.api.webhooks.list().then(function(list) {\n            var hook_id = null;\n\n            for (var i = 0; i < list.items.length; i++) {\n                if (list.items[i].name == webhook_name) {\n                    hook_id = list.items[i].id;\n                }\n            }\n\n            var hook_url = 'https://' + controller.config.public_address + '/ciscospark/receive';\n\n            console.log('Cisco Spark: incoming webhook url is ', hook_url);\n\n            if (hook_id) {\n                controller.api.webhooks.update({\n                    id: hook_id,\n                    resource: 'all',\n                    targetUrl: hook_url,\n                    event: 'all',\n                    secret: controller.config.secret,\n                    name: webhook_name,\n                }).then(function(res) {\n                    console.log('Cisco Spark: SUCCESSFULLY UPDATED CISCO SPARK WEBHOOKS');\n                    if (cb) cb();\n                }).catch(function(err) {\n                    console.log('FAILED TO REGISTER WEBHOOK', err);\n                    throw new Error(err);\n                });\n\n            } else {\n                controller.api.webhooks.create({\n                    resource: 'all',\n                    targetUrl: hook_url,\n                    event: 'all',\n                    secret: controller.config.secret,\n                    name: webhook_name,\n                }).then(function(res) {\n\n                    console.log('Cisco Spark: SUCCESSFULLY REGISTERED CISCO SPARK WEBHOOKS');\n                    if (cb) cb();\n                }).catch(function(err) {\n                    console.log('FAILED TO REGISTER WEBHOOK', err);\n                    throw new Error(err);\n                });\n\n            }\n        });\n    };\n\n    controller.on('message_received', function(bot, message) {\n\n        if (controller.config.limit_to_org) {\n            console.log('limit to org', controller.config.limit_to_org,  message.original_message.orgId);\n            if (!message.original_message.orgId || message.original_message.orgId != controller.config.limit_to_org) {\n                // this message is from a user outside of the proscribed org\n                return false;\n            }\n        }\n\n        if (controller.config.limit_to_domain) {\n            var domains = [];\n            if (typeof(controller.config.limit_to_domain) == 'string') {\n                domains = [controller.config.limit_to_domain];\n            } else {\n                domains = controller.config.limit_to_domain;\n            }\n\n            var allowed = false;\n            for (var d = 0; d < domains.length; d++) {\n                if (message.user.toLowerCase().indexOf(domains[d]) >= 0) {\n                    allowed = true;\n                }\n            }\n\n            if (!allowed) {\n                // this message came from a domain that is outside of the allowed list.\n                return false;\n            }\n        }\n\n\n\n        if (message.user === controller.identity.emails[0]) {\n            controller.trigger('self_message', [bot, message]);\n            return false;\n        } else if (message.original_message.roomType == 'direct') {\n            controller.trigger('direct_message', [bot, message]);\n            return false;\n        } else {\n\n            controller.trigger('direct_mention', [bot, message]);\n            return false;\n        }\n    });\n\n    controller.handleWebhookPayload = function(req, res, bot) {\n\n        if (controller.config.secret) {\n            var signature = req.headers['x-spark-signature'];\n            var hash = crypto.createHmac('sha1', controller.config.secret).update(JSON.stringify(req.body)).digest('hex');\n\n            if (signature != hash) {\n                console.error('WARNING: Webhook received message with invalid signature. Potential malicious behavior!');\n                return false;\n            }\n        }\n\n        if (req.body.resource == 'messages' && req.body.event == 'created') {\n\n            // console.log('RAW MESSAGE',req.body);\n            controller.api.messages.get(req.body.data).then(function(message) {\n\n                // console.log('DECRYPTED MESSAGE', message);\n                // copy some fields from req.body that aren't in the new message\n                message.orgId = req.body.orgId;\n\n                var message = {\n                    user: message.personEmail,\n                    channel: message.roomId,\n                    text: message.text,\n                    id: message.id,\n                    original_message: message,\n                };\n\n                // remove @mentions of the bot from the source text before we ingest it\n                if (message.original_message.html) {\n\n                    // strip the mention & HTML from the message\n                    var pattern = new RegExp('^\\<p\\>\\<spark\\-mention .*?data\\-object\\-id\\=\\\"' + controller.identity.id + '\\\".*\\>.*?\\<\\/spark\\-mention\\>');\n                    var action = message.original_message.html.replace(pattern, '');\n\n                    // strip the remaining HTML tags\n                    action = action.replace(/\\<.*?\\>/img, '');\n\n                    // strip remaining whitespace\n                    action = action.trim();\n\n                    // replace the message text with the the HTML version\n                    message.text = action;\n\n                } else {\n                    var pattern = new RegExp('^' + controller.identity.displayName + '\\\\s+', 'i');\n                    if (message.text) {\n                        message.text = message.text.replace(pattern, '');\n                    }\n                }\n                controller.receiveMessage(bot, message);\n\n            }).catch(function(err) {\n                console.error('Could not get message', err);\n            });\n        } else {\n\n            var event = req.body.resource + '.' + req.body.event;\n\n            var message = {\n                user: req.body.data.personEmail,\n                channel: req.body.data.roomId,\n                id: req.body.data.id,\n                original_message: req.body,\n                type: event,\n            };\n\n            switch (event) {\n                case 'memberships.deleted':\n                    if (message.user === controller.identity.emails[0]) {\n                        controller.trigger('bot_space_leave', [bot, message]);\n                    } else {\n                        controller.trigger('user_space_leave', [bot, message]);\n                    }\n                    break;\n                case 'memberships.created':\n                    if (message.user === controller.identity.emails[0]) {\n                        controller.trigger('bot_space_join', [bot, message]);\n                    } else {\n                        controller.trigger('user_space_join', [bot, message]);\n                    }\n                    break;\n            }\n\n            controller.trigger(event, [bot, message]);\n        }\n    };\n\n    controller.setupWebserver = function(port, cb) {\n\n        if (!port) {\n            throw new Error('Cannot start webserver without a port');\n        }\n\n        var static_dir =  __dirname + '/public';\n\n        if (controller.config && controller.config.webserver && controller.config.webserver.static_dir)\n            static_dir = controller.config.webserver.static_dir;\n\n        controller.config.port = port;\n\n        controller.webserver = express();\n        controller.webserver.use(bodyParser.json());\n        controller.webserver.use(bodyParser.urlencoded({ extended: true }));\n        controller.webserver.use(express.static(static_dir));\n\n        var server = controller.webserver.listen(\n            controller.config.port,\n            controller.config.hostname,\n            function() {\n                controller.log('** Starting webserver on port ' +\n                    controller.config.port);\n                if (cb) { cb(null, controller.webserver); }\n            });\n\n        return controller;\n\n    };\n\n\n    // customize the bot definition, which will be used when new connections\n    // spawn!\n    controller.defineBot(function(botkit, config) {\n\n        var bot = {\n            type: 'ciscospark',\n            botkit: botkit,\n            config: config || {},\n            utterances: botkit.utterances,\n        };\n\n        bot.startConversation = function(message, cb) {\n            botkit.startConversation(this, message, cb);\n        };\n\n        bot.createConversation = function(message, cb) {\n            botkit.createConversation(this, message, cb);\n        };\n\n\n        /**\n         * Convenience method for creating a DM convo.\n         */\n        bot.startPrivateConversation = function(message, cb) {\n\n            var message_options = {};\n\n            message_options.toPersonEmail = message.user;\n\n            botkit.startTask(bot, message_options, function(task, convo) {\n                convo.on('sent', function(sent_message) {\n                    // update this convo so that future messages will match\n                    // since the source message did not have this info in it.\n                    convo.source_message.user = message.user;\n                    convo.source_message.channel = sent_message.roomId;\n                });\n                cb(null, convo);\n            });\n        };\n\n\n        /**\n         * Convenience method for creating a DM based on a personId instead of email\n         */\n        bot.startPrivateConversationWithPersonId = function(personId, cb) {\n\n            var message_options = {};\n\n            message_options.toPersonId = personId;\n\n            botkit.startTask(bot, message_options, function(task, convo) {\n                convo.on('sent', function(sent_message) {\n                    // update this convo so that future messages will match\n                    // since the source message did not have this info in it.\n                    convo.source_message.user = message.user;\n                    convo.source_message.channel = sent_message.roomId;\n                });\n                cb(null, convo);\n            });\n        };\n\n\n        /**\n         * Convenience method for creating a DM convo with the `actor`, not the sender\n         * this applies to events like channel joins, where the actor may be the user who sent the invite\n         */\n        bot.startPrivateConversationWithActor = function(message, cb) {\n            bot.startPrivateConversationWithPersonId(message.original_message.actorId, cb);\n        };\n\n\n        bot.send = function(message, cb) {\n\n            // clone the incoming message\n            var ciscospark_message = {};\n            for (var k in message) {\n                ciscospark_message[k] = message[k];\n            }\n\n            // mutate the message into proper spark format\n            ciscospark_message.roomId = message.channel;\n            delete ciscospark_message.channel;\n\n            // default the markdown field to be the same as tex.\n            if (ciscospark_message.text && !ciscospark_message.markdown) {\n                ciscospark_message.markdown = ciscospark_message.text;\n            }\n\n            controller.api.messages.create(ciscospark_message).then(function(message) {\n                if (cb) cb(null, message);\n            }).catch(function(err) {\n                if (cb) cb(err);\n            });\n\n        };\n\n        bot.reply = function(src, resp, cb) {\n            var msg = {};\n\n            if (typeof(resp) == 'string') {\n                msg.text = resp;\n            } else {\n                msg = resp;\n            }\n\n            if (src.channel) {\n                msg.channel = src.channel;\n            } else if (src.toPersonEmail) {\n                msg.toPersonEmail = src.toPersonEmail;\n            } else if (src.toPersonId) {\n                msg.toPersonId = src.toPersonId;\n            }\n\n            bot.say(msg, cb);\n        };\n\n        bot.findConversation = function(message, cb) {\n            botkit.debug('CUSTOM FIND CONVO', message.user, message.channel);\n            for (var t = 0; t < botkit.tasks.length; t++) {\n                for (var c = 0; c < botkit.tasks[t].convos.length; c++) {\n                    if (\n                        botkit.tasks[t].convos[c].isActive() &&\n                        botkit.tasks[t].convos[c].source_message.user == message.user &&\n                        botkit.tasks[t].convos[c].source_message.channel == message.channel\n                    ) {\n                        botkit.debug('FOUND EXISTING CONVO!');\n                        cb(botkit.tasks[t].convos[c]);\n                        return;\n                    }\n                }\n            }\n\n            cb();\n        };\n\n        bot.retrieveFileInfo = function(url, cb) {\n            request.head({\n                url: url,\n                headers: {\n                    'Authorization': 'Bearer ' + controller.config.ciscospark_access_token\n                },\n            }, function(err, response, body) {\n\n                if (!err) {\n                    var obj = response.headers;\n                    if (obj['content-disposition']) {\n                        obj.filename = obj['content-disposition'].replace(/.*filename=\\\"(.*)\\\".*/gi, '$1');\n                    }\n                    cb(null, obj);\n                } else {\n                    cb(err);\n                }\n\n            });\n        };\n\n        bot.retrieveFile = function(url, cb) {\n\n            request({\n                url: url,\n                headers: {\n                    'Authorization': 'Bearer ' + controller.config.ciscospark_access_token\n                },\n                encoding: 'binary',\n            }, function(err, response, body) {\n\n                cb(err, body);\n\n            });\n\n        };\n\n        return bot;\n\n    });\n\n    controller.startTicking();\n\n    return controller;\n\n}\n\n\nmodule.exports = Sparkbot;\n","/home/travis/build/npmtest/node-npmtest-botkit/botkit/lib/ConsoleBot.js":"var Botkit = require(__dirname + '/CoreBot.js');\nvar request = require('request');\nvar express = require('express');\nvar bodyParser = require('body-parser');\nvar readline = require('readline');\n\n\nfunction TextBot(configuration) {\n\n    // Create a core botkit bot\n    var text_botkit = Botkit(configuration || {});\n\n\n    text_botkit.middleware.spawn.use(function(bot, next) {\n\n        text_botkit.listenStdIn(bot);\n        next();\n\n    });\n\n    text_botkit.defineBot(function(botkit, config) {\n\n        var bot = {\n            botkit: botkit,\n            config: config || {},\n            utterances: botkit.utterances,\n        };\n\n        bot.startConversation = function(message, cb) {\n            botkit.startConversation(this, message, cb);\n        };\n\n        bot.send = function(message, cb) {\n            console.log('BOT:', message.text);\n        };\n\n        bot.reply = function(src, resp, cb) {\n            var msg = {};\n\n            if (typeof(resp) == 'string') {\n                msg.text = resp;\n            } else {\n                msg = resp;\n            }\n\n            msg.channel = src.channel;\n\n            bot.say(msg, cb);\n        };\n\n        bot.findConversation = function(message, cb) {\n            botkit.debug('CUSTOM FIND CONVO', message.user, message.channel);\n            for (var t = 0; t < botkit.tasks.length; t++) {\n                for (var c = 0; c < botkit.tasks[t].convos.length; c++) {\n                    if (\n                        botkit.tasks[t].convos[c].isActive() &&\n                        botkit.tasks[t].convos[c].source_message.user == message.user\n                    ) {\n                        botkit.debug('FOUND EXISTING CONVO!');\n                        cb(botkit.tasks[t].convos[c]);\n                        return;\n                    }\n                }\n            }\n\n            cb();\n        };\n\n        return bot;\n\n    });\n\n    text_botkit.listenStdIn = function(bot) {\n\n        text_botkit.startTicking();\n        var rl = readline.createInterface({ input: process.stdin, output: process.stdout, terminal: false });\n        rl.on('line', function(line) {\n            var message = {\n                text: line,\n                user: 'user',\n                channel: 'text',\n                timestamp: Date.now()\n            };\n            text_botkit.receiveMessage(bot, message);\n        });\n    };\n\n    return text_botkit;\n};\n\nmodule.exports = TextBot;\n"}